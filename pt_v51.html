<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文白對譯平台</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Noto Serif TC", "Source Han Serif TC", serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 16px;
            color: #7f8c8d;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .tab-button {
            flex: 1;
            padding: 16px 24px;
            font-size: 15px;
            font-family: inherit;
            font-weight: 600;
            color: #7f8c8d;
            background: #fff;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: #f8f9fa;
            color: #2c3e50;
        }

        .tab-button.active {
            color: #3498db;
            border-bottom-color: #3498db;
            background: #f8f9fa;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Settings Panel - New Design */
        .settings-panel {
            background: #fff;
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .settings-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 16px;
            border-bottom: 2px solid #3498db;
            margin-bottom: 20px;
        }

        .settings-title {
            font-size: 15px;
            color: #2c3e50;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-title svg {
            width: 18px;
            height: 18px;
            color: #7f8c8d;
        }

        .settings-grid {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .settings-group {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }

        .settings-group-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
            padding-right: 8px;
            border-right: 1px solid #e0e0e0;
        }

        .settings-group-label svg {
            width: 14px;
            height: 14px;
        }

        .settings-group-items {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .setting-label {
            font-size: 11px;
            color: #7f8c8d;
            text-align: center;
            white-space: nowrap;
        }

        /* Toggle Switch - Vertical Style */
        .toggle-switch {
            position: relative;
            width: 28px;
            height: 52px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #3498db;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateY(-24px);
        }

        .toggle-switch input:checked + .toggle-slider.addition-slider {
            background-color: #f39c12;
        }

        .toggle-switch input:checked + .toggle-slider.ellipsis-slider {
            background-color: #9b59b6;
        }

        .toggle-switch input:checked + .toggle-slider.paraphrase-slider {
            background-color: #e74c3c;
        }

        .toggle-switch input:checked + .toggle-slider.reorder-slider {
            background-color: #3498db;
        }

        .toggle-switch input:checked + .toggle-slider.reconstruction-slider {
            background-color: #4CAF50;
        }

        .toggle-switch input:checked + .toggle-slider.loan-slider {
            background-color: #00bcd4;
        }

        .toggle-switch input:checked + .toggle-slider.archaic-slider {
            background-color: #795548;
        }

        .toggle-switch input:checked + .toggle-slider.multi-highlight-slider {
            background-color: #27ae60;
        }

        .toggle-switch input:checked + .toggle-slider.classical-slider {
            background-color: #9b59b6;
        }

        .toggle-switch input:checked + .toggle-slider.modern-slider {
            background-color: #27ae60;
        }

        .toggle-switch input:checked + .toggle-slider.hint-slider {
            background-color: #e67e22;
        }

        /* Sentence Block Container */
        .sentence-blocks-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sentence-block {
            position: relative;
            background: #fff;
            border-radius: 12px;
            padding: 20px 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        /* Combined Selector Section */
        .combined-selector {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #ecf0f1;
        }

        .selector-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .selector-label {
            font-size: 14px;
            color: #2c3e50;
            font-weight: 600;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 60px;
        }

        .selector-label svg {
            width: 18px;
            height: 18px;
            color: #7f8c8d;
        }

        /* Dropdown Select */
        .selector-dropdown {
            position: relative;
        }

        .selector-dropdown select {
            width: 100%;
            padding: 10px 40px 10px 16px;
            font-size: 14px;
            font-family: inherit;
            color: #2c3e50;
            background: #f8f9fa;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            appearance: none;
            transition: all 0.2s ease;
        }

        .selector-dropdown select:hover {
            border-color: #3498db;
        }

        .selector-dropdown select:focus {
            outline: none;
            border-color: #3498db;
            background: #fff;
        }

        .selector-dropdown::after {
            content: '';
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid #7f8c8d;
            pointer-events: none;
        }

        /* Chapter dropdown - full width */
        .selector-dropdown.chapter-dropdown {
            flex: 1;
        }

        /* Enhanced Sentence Selector with Navigation */
        .sentence-selector-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        /* New layout: dropdown, search, type filter, nav controls */
        .sentence-selector-wrapper .selector-dropdown {
            flex: 1.2;
            min-width: 0;
        }

        .sentence-filter-input {
            flex: 0.8;
            min-width: 0;
            padding: 10px 12px;
            font-size: 13px;
            font-family: inherit;
            color: #2c3e50;
            background: #fff;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .sentence-filter-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .sentence-filter-input::placeholder {
            color: #bdc3c7;
        }

        /* Type filter dropdown */
        .type-filter-dropdown {
            position: relative;
            flex: 0.6;
            min-width: 80px;
        }

        .type-filter-dropdown select {
            width: 100%;
            padding: 10px 30px 10px 12px;
            font-size: 13px;
            font-family: inherit;
            color: #2c3e50;
            background: #f8f9fa;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            appearance: none;
            transition: all 0.2s ease;
        }

        .type-filter-dropdown select:hover {
            border-color: #3498db;
        }

        .type-filter-dropdown select:focus {
            outline: none;
            border-color: #3498db;
            background: #fff;
        }

        .type-filter-dropdown::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #7f8c8d;
            pointer-events: none;
        }

        .sentence-nav-controls {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
        }

        .sentence-nav-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid #ecf0f1;
            background: #f8f9fa;
            color: #7f8c8d;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .sentence-nav-btn:hover:not(:disabled) {
            border-color: #3498db;
            color: #3498db;
            background: #fff;
        }

        .sentence-nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .sentence-nav-btn svg {
            width: 14px;
            height: 14px;
        }

        .sentence-progress {
            font-size: 12px;
            color: #7f8c8d;
            white-space: nowrap;
            min-width: 60px;
            text-align: center;
            font-family: 'SF Mono', 'Consolas', monospace;
        }

        .sentence-jump-input {
            width: 45px;
            padding: 6px 8px;
            font-size: 12px;
            font-family: 'SF Mono', 'Consolas', monospace;
            text-align: center;
            color: #2c3e50;
            background: #fff;
            border: 2px solid #ecf0f1;
            border-radius: 6px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .sentence-jump-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .sentence-jump-input::placeholder {
            color: #bdc3c7;
        }

        .source-info-inline {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            padding: 8px 0;
            align-items: center;
        }

        .source-info-inline .info-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .source-info-inline .label {
            font-size: 12px;
            color: #95a5a6;
        }

        .source-info-inline .value {
            font-size: 13px;
            color: #2c3e50;
            font-weight: 500;
        }

        /* Comment tag styling */
        .comment-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: #e8f4fc;
            border: 1px solid #3498db;
            border-radius: 12px;
            font-size: 12px;
            color: #2980b9;
            margin-left: 8px;
        }

        .comment-tag svg {
            width: 12px;
            height: 12px;
        }

        /* Hint tag styling */
        .hint-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: #fef9e7;
            border: 1px solid #f39c12;
            border-radius: 12px;
            font-size: 12px;
            color: #e67e22;
            margin-left: 8px;
        }

        .hint-tag svg {
            width: 12px;
            height: 12px;
        }

        .hint-tag.hidden {
            display: none;
        }

        /* Add/Remove Sentence Buttons */
        .block-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .add-sentence-btn, .remove-sentence-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #3498db;
            background: #fff;
            color: #3498db;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .add-sentence-btn:hover {
            background: #3498db;
            color: #fff;
        }

        .remove-sentence-btn {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .remove-sentence-btn:hover {
            background: #e74c3c;
            color: #fff;
        }

        .render-card {
            background: #fff;
            border-radius: 12px;
            padding: 20px 0;
        }

        .alignment-container {
            display: flex;
            justify-content: flex-start;
            gap: 0;
            overflow-x: auto;
            padding: 20px 0;
            flex-wrap: wrap;
            position: relative;
        }

        /* Addition group wrapper */
        .addition-group-wrapper {
            display: flex;
            position: relative;
            padding: 4px;
            margin: -4px;
            transition: all 0.3s ease;
        }

        .addition-group-wrapper.enhanced {
            background: #fef9e7;
            border: 2px dashed #f39c12;
            margin: -4px 2px;
        }

        /* Scope group wrapper - for scope-based addition highlighting */
        .scope-group-wrapper {
            display: flex;
            position: relative;
            padding: 4px;
            margin: -4px;
            transition: all 0.3s ease;
        }

        .scope-group-wrapper.enhanced {
            background: #fef9e7;
            border: 2px dashed #f39c12;
            margin: -4px 2px;
        }

        /* Paraphrase group wrapper - for range-based paraphrase highlighting */
        .paraphrase-group-wrapper {
            display: flex;
            position: relative;
            padding: 4px;
            margin: -4px;
            transition: all 0.3s ease;
        }

        .paraphrase-group-wrapper.enhanced {
            background: #fdf2f2;
            border: 2px dashed #e74c3c;
            margin: -4px 2px;
        }

        /* Reorder group wrapper */
        .reorder-group-wrapper {
            display: flex;
            position: relative;
            padding: 4px;
            margin: -4px;
            transition: all 0.3s ease;
        }

        .reorder-group-wrapper.enhanced {
            background: #e8f4fc;
            border: 2px dashed #3498db;
            margin: -4px 2px;
        }

        .reorder-group-wrapper.group-B.enhanced {
            background: #e8f8f5;
            border-color: #1abc9c;
        }

        /* Reconstruction frame wrapper */
        .reconstruction-frame-wrapper {
            display: flex;
            position: relative;
            padding: 4px;
            margin: -4px;
            transition: all 0.3s ease;
        }

        .reconstruction-frame-wrapper.enhanced {
            background: #e8f5e9;
            border: 2px dashed #4CAF50;
            margin: -4px 2px;
        }

        .token-pair {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 10px;
            transition: all 0.2s ease;
            cursor: pointer;
            min-width: 50px;
            position: relative;
        }

        .token-pair:hover {
            background: #f8f9fa;
        }

        /* Highlighted state */
        .token-pair.highlighted,
        .token-pair.pair-highlighted,
        .token-pair.trigger-highlighted {
            background: #e8f4f8;
        }

        /* Frame highlighted state (for lexical meaning - hover/click) */
        .token-pair.frame-highlighted {
            background: #e8f5e9 !important;
        }

        .token-pair.frame-highlighted .token-classical {
            color: #4CAF50 !important;
        }

        .token-pair.frame-highlighted .token-modern {
            color: #388E3C !important;
        }

        .token-pair.frame-highlighted .token-connector {
            background: #4CAF50 !important;
            width: 2px !important;
            height: 20px !important;
        }

        /* Addition frame highlighted state (scope-based) */
        .token-pair.addition-frame-highlighted {
            background: #fef9e7 !important;
        }

        .token-pair.addition-frame-highlighted .token-classical {
            color: #f39c12 !important;
        }

        .token-pair.addition-frame-highlighted .token-modern {
            color: #e67e22 !important;
        }

        .token-pair.addition-frame-highlighted .token-connector {
            background: #f39c12 !important;
            width: 2px !important;
            height: 20px !important;
        }

        /* Scope highlighted state */
        .token-pair.scope-highlighted {
            background: #fef9e7 !important;
        }

        .token-pair.scope-highlighted .token-classical {
            color: #f39c12 !important;
        }

        .token-pair.scope-highlighted .token-modern {
            color: #e67e22 !important;
        }

        .token-pair.scope-highlighted .token-connector {
            background: #f39c12 !important;
            width: 2px !important;
            height: 20px !important;
        }

        /* Paraphrase range highlighted state */
        .token-pair.paraphrase-range-highlighted {
            background: #fdf2f2 !important;
        }

        .token-pair.paraphrase-range-highlighted .token-classical {
            color: #e74c3c !important;
        }

        .token-pair.paraphrase-range-highlighted .token-modern {
            color: #c0392b !important;
        }

        .token-pair.paraphrase-range-highlighted .token-connector {
            background: #e74c3c !important;
            width: 2px !important;
            height: 20px !important;
        }

        .token-pair.paraphrase-range-highlighted .paraphrase-connector {
            background: #e74c3c !important;
        }

        /* Hover and highlight connector vertical */
        .token-pair:hover .token-connector,
        .token-pair.highlighted .token-connector,
        .token-pair.pair-highlighted .token-connector,
        .token-pair.trigger-highlighted .token-connector {
            width: 2px;
            height: 20px;
            background: #3498db;
        }

        /* Hover and highlight text color */
        .token-pair:hover .token-classical,
        .token-pair.highlighted .token-classical,
        .token-pair.pair-highlighted .token-classical,
        .token-pair.trigger-highlighted .token-classical {
            color: #3498db;
        }

        .token-pair:hover .token-modern,
        .token-pair.highlighted .token-modern,
        .token-pair.pair-highlighted .token-modern,
        .token-pair.trigger-highlighted .token-modern {
            color: #3498db;
        }

        /* Addition type styling */
        .token-pair.type-addition.enhanced {
            background: transparent;
        }

        .token-pair.type-addition.enhanced:hover {
            background: rgba(243, 156, 18, 0.1);
        }

        .addition-group-wrapper.enhanced .token-pair:hover {
            background: rgba(243, 156, 18, 0.15);
        }

        .addition-group-wrapper.enhanced .token-pair.highlighted,
        .addition-group-wrapper.enhanced .token-pair.trigger-highlighted {
            background: rgba(243, 156, 18, 0.2);
        }

        .scope-group-wrapper.enhanced .token-pair:hover {
            background: rgba(243, 156, 18, 0.15);
        }

        .scope-group-wrapper.enhanced .token-pair.highlighted,
        .scope-group-wrapper.enhanced .token-pair.scope-highlighted {
            background: rgba(243, 156, 18, 0.2);
        }

        /* Paraphrase group wrapper hover/highlight */
        .paraphrase-group-wrapper.enhanced .token-pair:hover {
            background: rgba(231, 76, 60, 0.15);
        }

        .paraphrase-group-wrapper.enhanced .token-pair.highlighted,
        .paraphrase-group-wrapper.enhanced .token-pair.paraphrase-range-highlighted {
            background: rgba(231, 76, 60, 0.2);
        }

        /* Addition trigger highlight */
        .token-pair.trigger-highlighted {
            background: #fef9e7 !important;
        }

        .token-pair.trigger-highlighted .token-classical {
            color: #f39c12 !important;
        }

        .token-pair.trigger-highlighted .token-modern {
            color: #e67e22 !important;
        }

        .token-pair.trigger-highlighted .token-connector {
            background: #f39c12 !important;
        }

        /* Ellipsis type styling - ONLY for ellipsis button enhancement */
        .token-pair.enhanced-ellipsis-only {
            background: #f5eef8 !important;
        }

        .token-pair.enhanced-ellipsis-only:hover {
            background: #ebe0f5 !important;
        }

        .token-pair.enhanced-ellipsis-only .token-classical {
            color: #9b59b6 !important;
        }

        .token-pair.enhanced-ellipsis-only .token-modern {
            color: #8e44ad !important;
        }

        .token-pair.enhanced-ellipsis-only .token-connector {
            background: #9b59b6 !important;
        }

        /* Paraphrase type styling */
        .token-pair.type-paraphrase {
            transition: all 0.3s ease;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase {
            background: #fdf2f2;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase:hover {
            background: #fce8e8;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase .token-classical {
            color: #e74c3c;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase .token-modern {
            color: #c0392b;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase .token-connector {
            background: #e74c3c;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase .paraphrase-connector {
            background: #e74c3c;
        }

        /* Reorder type styling - ONLY for reorder button enhancement */
        .token-pair.enhanced-reorder-only {
            background: #e8f4fc !important;
        }

        .token-pair.enhanced-reorder-only:hover {
            background: #d4e9f7 !important;
        }

        .token-pair.enhanced-reorder-only .token-classical {
            color: #3498db !important;
        }

        .token-pair.enhanced-reorder-only .token-modern {
            color: #2980b9 !important;
        }

        .token-pair.enhanced-reorder-only .token-connector {
            background: #3498db !important;
        }

        .token-pair.enhanced-reorder-only.group-B {
            background: #e8f8f5 !important;
        }

        .token-pair.enhanced-reorder-only.group-B:hover {
            background: #d5f4ed !important;
        }

        .token-pair.enhanced-reorder-only.group-B .token-classical {
            color: #1abc9c !important;
        }

        .token-pair.enhanced-reorder-only.group-B .token-modern {
            color: #16a085 !important;
        }

        .token-pair.enhanced-reorder-only.group-B .token-connector {
            background: #1abc9c !important;
        }

        .reorder-group-wrapper.enhanced .token-pair:hover {
            background: rgba(52, 152, 219, 0.15);
        }

        .reorder-group-wrapper.enhanced .token-pair.highlighted {
            background: rgba(52, 152, 219, 0.2);
        }

        .reorder-group-wrapper.group-B.enhanced .token-pair:hover {
            background: rgba(26, 188, 156, 0.15);
        }

        .reorder-group-wrapper.group-B.enhanced .token-pair.highlighted {
            background: rgba(26, 188, 156, 0.2);
        }

        /* Reconstruction type styling */
        .token-pair.type-reconstruction {
            transition: all 0.3s ease;
        }

        .token-pair.enhanced-reconstruction {
            background: #e8f5e9;
        }

        .token-pair.enhanced-reconstruction:hover {
            background: #c8e6c9;
        }

        .token-pair.enhanced-reconstruction .token-classical {
            color: #4CAF50;
        }

        .token-pair.enhanced-reconstruction .token-modern {
            color: #388E3C;
        }

        .token-pair.enhanced-reconstruction .token-connector {
            background: #4CAF50;
        }

        .reconstruction-frame-wrapper.enhanced .token-pair:hover {
            background: rgba(76, 175, 80, 0.15);
        }

        .reconstruction-frame-wrapper.enhanced .token-pair.highlighted {
            background: rgba(76, 175, 80, 0.2);
        }

        /* Combined highlight styles - when both ellipsis and reorder are enhanced */
        .token-pair.enhanced-ellipsis-only.enhanced-reorder-only {
            background: linear-gradient(135deg, #f5eef8 50%, #e8f4fc 50%) !important;
        }

        .token-pair.enhanced-ellipsis-only.enhanced-reorder-only:hover {
            background: linear-gradient(135deg, #ebe0f5 50%, #d4e9f7 50%) !important;
        }

        .token-pair.enhanced-ellipsis-only.enhanced-reorder-only.group-B {
            background: linear-gradient(135deg, #f5eef8 50%, #e8f8f5 50%) !important;
        }

        .token-pair.enhanced-ellipsis-only.enhanced-reorder-only.group-B:hover {
            background: linear-gradient(135deg, #ebe0f5 50%, #d5f4ed 50%) !important;
        }

        /* Phonetic Loan (通假) type styling */
        .token-pair.type-loan {
            transition: all 0.3s ease;
        }

        .token-pair.type-loan.enhanced-loan {
            background: #e0f7fa;
        }

        .token-pair.type-loan.enhanced-loan:hover {
            background: #b2ebf2;
        }

        .token-pair.type-loan.enhanced-loan .token-classical {
            color: #00bcd4;
        }

        .token-pair.type-loan.enhanced-loan .token-modern {
            color: #0097a7;
        }

        .token-pair.type-loan.enhanced-loan .token-connector {
            background: #00bcd4;
        }

        /* Loan bracket styling */
        .loan-bracket {
            color: #00bcd4;
            font-weight: 400;
        }

        /* Archaic Character (古今字) type styling */
        .token-pair.type-archaic {
            transition: all 0.3s ease;
        }

        .token-pair.type-archaic.enhanced-archaic {
            background: #efebe9;
        }

        .token-pair.type-archaic.enhanced-archaic:hover {
            background: #d7ccc8;
        }

        .token-pair.type-archaic.enhanced-archaic .token-classical {
            color: #795548;
        }

        .token-pair.type-archaic.enhanced-archaic .token-modern {
            color: #5d4037;
        }

        .token-pair.type-archaic.enhanced-archaic .token-connector {
            background: #795548;
        }

        /* Archaic bracket styling */
        .archaic-bracket {
            color: #795548;
            font-weight: 400;
        }

        /* Reconstruction bracket styling */
        .reconstruction-bracket {
            color: #4CAF50;
            font-weight: 400;
        }

        /* Token Index */
        .token-index {
            font-size: 11px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: #bdc3c7;
            padding: 2px 6px;
            background: #f8f9fa;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
            min-width: 20px;
            text-align: center;
        }

        .token-index.visible {
            opacity: 1;
        }

        .token-index.classical-index {
            color: #9b59b6;
            background: #f5eef8;
        }

        .token-index.modern-index {
            color: #27ae60;
            background: #e8f8f0;
        }

        .token-index.addition-index {
            color: #f39c12;
            background: #fef9e7;
        }

        .token-classical {
            font-size: 24px;
            color: #2c3e50;
            padding: 10px 5px;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hidden classical tokens */
        .token-classical.hidden-token {
            opacity: 0;
        }

        .token-pair:hover .token-classical.hidden-token,
        .token-pair.highlighted .token-classical.hidden-token,
        .token-pair.pair-highlighted .token-classical.hidden-token,
        .token-pair.trigger-highlighted .token-classical.hidden-token {
            opacity: 1;
        }

        .addition-group-wrapper.enhanced .token-pair:hover .token-classical,
        .addition-group-wrapper.enhanced .token-pair.highlighted .token-classical {
            color: #f39c12;
        }

        .scope-group-wrapper.enhanced .token-pair:hover .token-classical,
        .scope-group-wrapper.enhanced .token-pair.highlighted .token-classical,
        .scope-group-wrapper.enhanced .token-pair.scope-highlighted .token-classical {
            color: #f39c12;
        }

        .reorder-group-wrapper.enhanced .token-pair:hover .token-classical,
        .reorder-group-wrapper.enhanced .token-pair.highlighted .token-classical {
            color: #3498db;
        }

        .reorder-group-wrapper.group-B.enhanced .token-pair:hover .token-classical,
        .reorder-group-wrapper.group-B.enhanced .token-pair.highlighted .token-classical {
            color: #1abc9c;
        }

        .reconstruction-frame-wrapper.enhanced .token-pair:hover .token-classical,
        .reconstruction-frame-wrapper.enhanced .token-pair.highlighted .token-classical {
            color: #4CAF50;
        }

        .paraphrase-group-wrapper.enhanced .token-pair:hover .token-classical,
        .paraphrase-group-wrapper.enhanced .token-pair.highlighted .token-classical,
        .paraphrase-group-wrapper.enhanced .token-pair.paraphrase-range-highlighted .token-classical {
            color: #e74c3c;
        }

        /* Empty classical token (for additions and reconstruction duplicates) - hidden by default */
        .token-classical.empty {
            color: #f39c12;
            font-size: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .token-classical.empty.visible {
            opacity: 1;
        }

        .token-classical.empty.reconstruction-empty {
            color: #4CAF50;
        }

        /* Reorder empty slot - hidden by default, show only when index is visible */
        .token-classical.reorder-empty,
        .token-modern.reorder-empty {
            color: #bdc3c7;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s ease;
            min-height: 50px;
        }

        .token-classical.reorder-empty.visible,
        .token-modern.reorder-empty.visible {
            opacity: 1;
        }

        .token-modern.reorder-empty {
            min-height: 40px;
        }

        .token-classical.reorder-empty.group-B,
        .token-modern.reorder-empty.group-B {
            color: #bdc3c7;
        }

        /* Token connector - default horizontal, vertical when highlighted or hovered */
        .token-connector {
            width: 20px;
            height: 2px;
            background: #bdc3c7;
            margin: 5px 0;
            transition: all 0.2s ease;
        }

        /* Addition connector - hidden by default */
        .token-pair.type-addition .token-connector {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .token-pair.type-addition .token-connector.visible {
            opacity: 1;
            background: #f5cba7;
        }

        .addition-group-wrapper.enhanced .token-pair .token-connector {
            background: #f5cba7;
        }

        .addition-group-wrapper.enhanced .token-pair:hover .token-connector,
        .addition-group-wrapper.enhanced .token-pair.highlighted .token-connector {
            background: #f39c12;
        }

        .scope-group-wrapper.enhanced .token-pair .token-connector {
            background: #f5cba7;
        }

        .scope-group-wrapper.enhanced .token-pair:hover .token-connector,
        .scope-group-wrapper.enhanced .token-pair.highlighted .token-connector,
        .scope-group-wrapper.enhanced .token-pair.scope-highlighted .token-connector {
            background: #f39c12;
        }

        /* Reorder connector - hidden for reorder-only slots */
        .token-pair.reorder-slot .token-connector {
            opacity: 0;
        }

        .token-pair.reorder-slot .token-connector.visible {
            opacity: 1;
        }

        /* Reconstruction duplicate connector - hidden by default */
        .token-pair.reconstruction-duplicate .token-connector {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .token-pair.reconstruction-duplicate .token-connector.visible {
            opacity: 1;
            background: #a5d6a7;
        }

        .token-modern {
            font-size: 16px;
            color: #7f8c8d;
            padding: 10px 5px;
            white-space: nowrap;
            transition: all 0.2s ease;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hidden modern tokens */
        .token-modern.hidden-token {
            opacity: 0;
        }

        .token-pair:hover .token-modern.hidden-token,
        .token-pair.highlighted .token-modern.hidden-token,
        .token-pair.pair-highlighted .token-modern.hidden-token,
        .token-pair.trigger-highlighted .token-modern.hidden-token {
            opacity: 1;
        }

        .token-pair.type-addition .token-modern {
            color: #7f8c8d;
        }

        .addition-group-wrapper.enhanced .token-pair.type-addition .token-modern {
            color: #e67e22;
            font-weight: 500;
        }

        .addition-group-wrapper.enhanced .token-pair:hover .token-modern,
        .addition-group-wrapper.enhanced .token-pair.highlighted .token-modern {
            color: #d35400;
        }

        .scope-group-wrapper.enhanced .token-pair.type-addition .token-modern {
            color: #e67e22;
            font-weight: 500;
        }

        .scope-group-wrapper.enhanced .token-pair:hover .token-modern,
        .scope-group-wrapper.enhanced .token-pair.highlighted .token-modern,
        .scope-group-wrapper.enhanced .token-pair.scope-highlighted .token-modern {
            color: #d35400;
        }

        .paraphrase-group-wrapper.enhanced .token-pair:hover .token-modern,
        .paraphrase-group-wrapper.enhanced .token-pair.highlighted .token-modern,
        .paraphrase-group-wrapper.enhanced .token-pair.paraphrase-range-highlighted .token-modern {
            color: #c0392b;
        }

        /* Ellipsis modern token with angle brackets */
        .token-pair.type-ellipsis .token-modern {
            color: #9b59b6;
        }

        /* Loan modern token styling */
        .token-pair.type-loan .token-modern {
            color: #00bcd4;
        }

        /* Archaic modern token styling */
        .token-pair.type-archaic .token-modern {
            color: #795548;
        }

        /* Reorder brackets - always visible */
        .reorder-bracket {
            color: #3498db;
            font-weight: 400;
        }

        .reorder-bracket.group-B {
            color: #1abc9c;
        }

        /* Ellipsis brackets - always visible */
        .ellipsis-bracket {
            color: #9b59b6;
            font-weight: 400;
        }

        /* Paraphrase marker - always visible */
        .paraphrase-marker {
            color: #e74c3c;
            font-weight: 500;
        }

        /* Paraphrase line (Line 3) */
        .paraphrase-connector {
            width: 20px;
            height: 2px;
            background: #bdc3c7;
            margin: 3px 0;
            transition: all 0.3s ease;
        }

        /* Paraphrase connector - DEFAULT is horizontal (for range continuation) */
        .paraphrase-connector.range-continuation {
            width: 20px;
            height: 2px;
            background: #bdc3c7;
        }

        /* When hovered/highlighted, change to diagonal for range continuation */
        .token-pair:hover .paraphrase-connector.range-continuation,
        .token-pair.highlighted .paraphrase-connector.range-continuation,
        .token-pair.pair-highlighted .paraphrase-connector.range-continuation,
        .token-pair.paraphrase-range-highlighted .paraphrase-connector.range-continuation {
            width: 15px;
            height: 2px;
            background: #e74c3c;
            transform: rotate(-45deg);
            transform-origin: center;
        }

        /* When hovered/highlighted, non-range connectors become vertical */
        .token-pair:hover .paraphrase-connector:not(.range-continuation),
        .token-pair.highlighted .paraphrase-connector:not(.range-continuation),
        .token-pair.pair-highlighted .paraphrase-connector:not(.range-continuation),
        .token-pair.paraphrase-range-highlighted .paraphrase-connector:not(.range-continuation) {
            width: 2px;
            height: 15px;
            background: #e74c3c;
        }

        .token-paraphrase {
            font-size: 14px;
            color: #e74c3c;
            padding: 6px 10px;
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        /* Empty paraphrase slot (placeholder for range continuation) */
        .token-paraphrase.empty-slot {
            opacity: 0;
            min-height: 26px;
        }

        /* Hidden paraphrase tokens - controlled by showModernTokens */
        .token-paraphrase.hidden-token {
            opacity: 0;
        }

        .token-pair:hover .token-paraphrase.hidden-token,
        .token-pair.highlighted .token-paraphrase.hidden-token,
        .token-pair.pair-highlighted .token-paraphrase.hidden-token,
        .token-pair.trigger-highlighted .token-paraphrase.hidden-token,
        .token-pair.paraphrase-range-highlighted .token-paraphrase.hidden-token {
            opacity: 1;
        }

        .token-pair.type-paraphrase.enhanced-paraphrase .token-paraphrase {
            font-weight: 500;
        }

        /* Addition anchor reference - hidden by default */
        .anchor-ref {
            font-size: 10px;
            color: #e67e22;
            font-family: 'SF Mono', 'Consolas', monospace;
            padding: 1px 4px;
            background: #fef3c7;
            border-radius: 3px;
            margin-top: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .anchor-ref.visible {
            opacity: 1;
        }

        /* Group label for addition groups */
        .group-label {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #e67e22;
            background: #fff;
            padding: 0 6px;
            border-radius: 3px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .group-label.visible {
            opacity: 1;
        }

        .group-label.reorder-label {
            color: #3498db;
        }

        .group-label.reorder-label.group-B {
            color: #1abc9c;
        }

        .group-label.reconstruction-label {
            color: #4CAF50;
        }

        .group-label.scope-label {
            color: #e67e22;
        }

        .group-label.paraphrase-label {
            color: #e74c3c;
        }

        /* Legend Card - Separate Section */
        .legend-card {
            background: #fff;
            border-radius: 16px;
            padding: 30px 40px;
            margin-top: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .legend h3 {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .legend-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 10px;
        }

        .legend-row:last-child {
            margin-bottom: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-symbol {
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            padding: 0 6px;
        }

        .legend-symbol.natural {
            background: #e8f8f5;
            color: #1abc9c;
        }

        .legend-symbol.addition {
            background: #fef9e7;
            color: #f39c12;
        }

        .legend-symbol.ellipsis {
            background: #f5eef8;
            color: #9b59b6;
        }

        .legend-symbol.paraphrase {
            background: #fdf2f2;
            color: #e74c3c;
        }

        .legend-symbol.reorder {
            background: #e8f4fc;
            color: #3498db;
        }

        .legend-symbol.reconstruction {
            background: #e8f5e9;
            color: #4CAF50;
        }

        .legend-symbol.loan {
            background: #e0f7fa;
            color: #00bcd4;
        }

        .legend-symbol.archaic {
            background: #efebe9;
            color: #795548;
        }

        .legend-label {
            font-size: 14px;
            color: #7f8c8d;
        }

        /* Addition sub-types explanation */
        .addition-subtypes {
            margin-top: 15px;
            padding: 15px;
            background: #fffbf0;
            border-radius: 8px;
            border: 1px solid #fef3c7;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .addition-subtypes.visible {
            opacity: 1;
            max-height: 200px;
            margin-top: 15px;
            padding: 15px;
        }

        .addition-subtypes h4 {
            font-size: 13px;
            color: #e67e22;
            margin-bottom: 10px;
        }

        .subtype-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #7f8c8d;
        }

        .subtype-item:last-child {
            margin-bottom: 0;
        }

        .subtype-code {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            padding: 2px 8px;
            background: #fef9e7;
            border-radius: 4px;
            color: #f39c12;
            min-width: 60px;
            text-align: center;
        }

        /* Ellipsis explanation */
        .ellipsis-explanation {
            margin-top: 15px;
            padding: 15px;
            background: #faf5ff;
            border-radius: 8px;
            border: 1px solid #e9d5ff;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .ellipsis-explanation.visible {
            opacity: 1;
            max-height: 150px;
            margin-top: 15px;
            padding: 15px;
        }

        .ellipsis-explanation h4 {
            font-size: 13px;
            color: #9b59b6;
            margin-bottom: 10px;
        }

        .ellipsis-explanation p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
        }

        .ellipsis-explanation .example {
            margin-top: 8px;
            padding: 8px 12px;
            background: #f5eef8;
            border-radius: 6px;
            font-size: 14px;
            color: #8e44ad;
        }

        /* Paraphrase explanation */
        .paraphrase-explanation {
            margin-top: 15px;
            padding: 15px;
            background: #fef7f7;
            border-radius: 8px;
            border: 1px solid #fecaca;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .paraphrase-explanation.visible {
            opacity: 1;
            max-height: 250px;
            margin-top: 15px;
            padding: 15px;
        }

        .paraphrase-explanation h4 {
            font-size: 13px;
            color: #e74c3c;
            margin-bottom: 10px;
        }

        .paraphrase-explanation p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
        }

        .paraphrase-explanation .example {
            margin-top: 8px;
            padding: 8px 12px;
            background: #fdf2f2;
            border-radius: 6px;
            font-size: 14px;
            color: #c0392b;
        }

        .paraphrase-explanation .structure {
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border-radius: 6px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            color: #7f8c8d;
            line-height: 1.8;
        }

        /* Reorder explanation */
        .reorder-explanation {
            margin-top: 15px;
            padding: 15px;
            background: #eff6ff;
            border-radius: 8px;
            border: 1px solid #bfdbfe;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .reorder-explanation.visible {
            opacity: 1;
            max-height: 300px;
            margin-top: 15px;
            padding: 15px;
        }

        .reorder-explanation h4 {
            font-size: 13px;
            color: #3498db;
            margin-bottom: 10px;
        }

        .reorder-explanation p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
        }

        .reorder-explanation .example {
            margin-top: 8px;
            padding: 8px 12px;
            background: #e8f4fc;
            border-radius: 6px;
            font-size: 14px;
            color: #2980b9;
        }

        .reorder-explanation .group-colors {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .reorder-explanation .group-color-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .reorder-explanation .color-box {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .reorder-explanation .color-box.group-a {
            background: #3498db;
        }

        .reorder-explanation .color-box.group-b {
            background: #1abc9c;
        }

        /* Reconstruction explanation */
        .reconstruction-explanation {
            margin-top: 15px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 8px;
            border: 1px solid #a5d6a7;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .reconstruction-explanation.visible {
            opacity: 1;
            max-height: 300px;
            margin-top: 15px;
            padding: 15px;
        }

        .reconstruction-explanation h4 {
            font-size: 13px;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .reconstruction-explanation p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
        }

        .reconstruction-explanation .example {
            margin-top: 8px;
            padding: 8px 12px;
            background: #c8e6c9;
            border-radius: 6px;
            font-size: 14px;
            color: #2e7d32;
        }

        .reconstruction-explanation .structure {
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border-radius: 6px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            color: #7f8c8d;
            line-height: 1.8;
        }

        /* Loan explanation */
        .loan-explanation {
            margin-top: 15px;
            padding: 15px;
            background: #e0f7fa;
            border-radius: 8px;
            border: 1px solid #b2ebf2;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .loan-explanation.visible {
            opacity: 1;
            max-height: 200px;
            margin-top: 15px;
            padding: 15px;
        }

        .loan-explanation h4 {
            font-size: 13px;
            color: #00bcd4;
            margin-bottom: 10px;
        }

        .loan-explanation p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
        }

        .loan-explanation .example {
            margin-top: 8px;
            padding: 8px 12px;
            background: #b2ebf2;
            border-radius: 6px;
            font-size: 14px;
            color: #0097a7;
        }

        /* Archaic explanation */
        .archaic-explanation {
            margin-top: 15px;
            padding: 15px;
            background: #efebe9;
            border-radius: 8px;
            border: 1px solid #d7ccc8;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .archaic-explanation.visible {
            opacity: 1;
            max-height: 200px;
            margin-top: 15px;
            padding: 15px;
        }

        .archaic-explanation h4 {
            font-size: 13px;
            color: #795548;
            margin-bottom: 10px;
        }

        .archaic-explanation p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
        }

        .archaic-explanation .example {
            margin-top: 8px;
            padding: 8px 12px;
            background: #d7ccc8;
            border-radius: 6px;
            font-size: 14px;
            color: #5d4037;
        }

        /* Index legend */
        .index-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #ecf0f1;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
            flex-wrap: wrap;
            align-items: center;
        }

        .index-legend.visible {
            opacity: 1;
            max-height: 100px;
        }

        .index-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #7f8c8d;
        }

        .index-legend-item .sample {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .index-legend-item .sample.classical {
            background: #f5eef8;
            color: #9b59b6;
        }

        .index-legend-item .sample.modern {
            background: #e8f8f0;
            color: #27ae60;
        }

        .index-legend-item .sample.addition {
            background: #fef9e7;
            color: #f39c12;
        }

        .raw-text {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .raw-text-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .raw-text-row:last-child {
            margin-bottom: 0;
        }

        .raw-text-row.hidden-row {
            display: none !important;
        }

        .raw-text-label {
            font-size: 13px;
            color: #95a5a6;
            width: 60px;
            flex-shrink: 0;
        }

        .raw-text-content {
            font-size: 18px;
            color: #2c3e50;
            letter-spacing: 1px;
        }

        .raw-text-content.modern {
            color: #7f8c8d;
            font-size: 16px;
        }

        .raw-text-content.paraphrase {
            color: #7f8c8d;
            font-size: 14px;
        }

        .raw-text-content.paraphrase .paraphrase-highlight {
            color: #e74c3c;
            font-weight: 500;
        }

        /* Info Tab Styles */
        .info-card {
            background: #fff;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .info-section {
            margin-bottom: 40px;
        }

        .info-section:last-child {
            margin-bottom: 0;
        }

        .info-section h2 {
            font-size: 20px;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .info-section h3 {
            font-size: 16px;
            color: #34495e;
            margin: 20px 0 12px 0;
        }

        .info-section p {
            font-size: 14px;
            color: #7f8c8d;
            line-height: 1.8;
            margin-bottom: 12px;
        }

        .info-section ul {
            margin: 12px 0;
            padding-left: 24px;
        }

        .info-section li {
            font-size: 14px;
            color: #7f8c8d;
            line-height: 1.8;
            margin-bottom: 8px;
        }

        .info-box {
            padding: 16px 20px;
            border-radius: 8px;
            margin: 16px 0;
        }

        .info-box.addition {
            background: #fef9e7;
            border-left: 4px solid #f39c12;
        }

        .info-box.ellipsis {
            background: #f5eef8;
            border-left: 4px solid #9b59b6;
        }

        .info-box.paraphrase {
            background: #fdf2f2;
            border-left: 4px solid #e74c3c;
        }

        .info-box.reorder {
            background: #e8f4fc;
            border-left: 4px solid #3498db;
        }

        .info-box.reconstruction {
            background: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }

        .info-box.loan {
            background: #e0f7fa;
            border-left: 4px solid #00bcd4;
        }

        .info-box.archaic {
            background: #efebe9;
            border-left: 4px solid #795548;
        }

        .info-box.principle {
            background: #e8f8f5;
            border-left: 4px solid #1abc9c;
        }

        .info-box.highlight {
            background: #e8f8f0;
            border-left: 4px solid #27ae60;
        }

        .info-box h4 {
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .info-box p {
            margin-bottom: 0;
        }

        .code-example {
            font-family: 'SF Mono', 'Consolas', monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
            color: #e74c3c;
        }

        /* Credits Section Styles */
        .credits-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #ecf0f1;
        }

        .credits-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .credits-header h2 {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .lang-toggle-btn {
            padding: 8px 16px;
            font-size: 13px;
            font-family: inherit;
            color: #3498db;
            background: #e8f4fc;
            border: 2px solid #3498db;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .lang-toggle-btn:hover {
            background: #3498db;
            color: #fff;
        }

        .credits-content {
            display: none;
        }

        .credits-content.active {
            display: block;
        }

        .credits-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 600px) {
            .credits-grid {
                grid-template-columns: 1fr;
            }
        }

        .credits-item {
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .credits-item .label {
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 4px;
        }

        .credits-item .value {
            font-size: 14px;
            color: #2c3e50;
            font-weight: 500;
        }

        .license-box {
            padding: 20px;
            background: #e8f8f5;
            border-radius: 8px;
            border-left: 4px solid #1abc9c;
            margin-bottom: 20px;
        }

        .license-box h4 {
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .license-box p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .license-box .citation {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            background: #fff;
            padding: 12px;
            border-radius: 6px;
            color: #34495e;
            line-height: 1.6;
        }

        .contact-box {
            padding: 20px;
            background: #e8f4fc;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .contact-box h4 {
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .contact-box p {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .contact-box a {
            color: #3498db;
            text-decoration: none;
        }

        .contact-box a:hover {
            text-decoration: underline;
        }

        /* Statistics Tab Styles */
        .stats-card {
            background: #fff;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .stats-section {
            margin-bottom: 30px;
        }

        .stats-section:last-child {
            margin-bottom: 0;
        }

        .stats-section h3 {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .stats-item {
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }

        .stats-item .number {
            font-size: 28px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 4px;
        }

        .stats-item .label {
            font-size: 13px;
            color: #7f8c8d;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .stats-table th,
        .stats-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .stats-table th {
            background: #f8f9fa;
            font-size: 13px;
            font-weight: 600;
            color: #2c3e50;
        }

        .stats-table td {
            font-size: 13px;
            color: #7f8c8d;
        }

        .stats-table tr:hover {
            background: #f8f9fa;
        }

        .stats-table .type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .stats-table .type-badge.natural { background: #e8f8f5; color: #1abc9c; }
        .stats-table .type-badge.ellipsis { background: #f5eef8; color: #9b59b6; }
        .stats-table .type-badge.addition { background: #fef9e7; color: #f39c12; }
        .stats-table .type-badge.paraphrase { background: #fdf2f2; color: #e74c3c; }
        .stats-table .type-badge.reorder { background: #e8f4fc; color: #3498db; }
        .stats-table .type-badge.reconstruction { background: #e8f5e9; color: #4CAF50; }
        .stats-table .type-badge.loan { background: #e0f7fa; color: #00bcd4; }
        .stats-table .type-badge.archaic { background: #efebe9; color: #795548; }

        .token-freq-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .token-freq-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background: #f8f9fa;
            border-radius: 20px;
            font-size: 13px;
        }

        .token-freq-item .token {
            color: #2c3e50;
            font-weight: 500;
        }

        .token-freq-item .freq {
            color: #95a5a6;
            font-size: 11px;
        }

        .token-freq-item.classical-token {
            background: #f5eef8;
        }

        .token-freq-item.classical-token .token {
            color: #9b59b6;
        }

        .token-freq-item.modern-token {
            background: #e8f8f0;
        }

        .token-freq-item.modern-token .token {
            color: #27ae60;
        }

        /* Download buttons */
        .download-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .download-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            font-size: 13px;
            font-family: inherit;
            font-weight: 500;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
        }

        .download-btn.classical-btn {
            color: #9b59b6;
            background: #f5eef8;
            border-color: #9b59b6;
        }

        .download-btn.classical-btn:hover {
            background: #9b59b6;
            color: #fff;
        }

        .download-btn.modern-btn {
            color: #27ae60;
            background: #e8f8f0;
            border-color: #27ae60;
        }

        .download-btn.modern-btn:hover {
            background: #27ae60;
            color: #fff;
        }

        .download-btn svg {
            width: 16px;
            height: 16px;
        }
		
/* Data Tab Styles */
        .data-card {
            background: #fff;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .data-section {
            margin-bottom: 30px;
        }

        .data-section:last-child {
            margin-bottom: 0;
        }

        .data-section h3 {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .data-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .data-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-family: inherit;
            font-weight: 500;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .data-btn.sample-btn {
            color: #3498db;
            background: #e8f4fc;
            border-color: #3498db;
        }

        .data-btn.sample-btn:hover {
            background: #3498db;
            color: #fff;
        }

        .data-btn.load-btn {
            color: #27ae60;
            background: #e8f8f0;
            border-color: #27ae60;
        }

        .data-btn.load-btn:hover {
            background: #27ae60;
            color: #fff;
        }

        .data-btn.apply-btn {
            color: #e67e22;
            background: #fef9e7;
            border-color: #e67e22;
        }

        .data-btn.apply-btn:hover {
            background: #e67e22;
            color: #fff;
        }

        .data-btn svg {
            width: 18px;
            height: 18px;
        }

/* Data Mode Radio Buttons */
        .data-mode-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 12px 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .data-mode-label {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .data-mode-options {
            display: flex;
            gap: 20px;
        }

        .data-mode-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .data-mode-option input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: #3498db;
            cursor: pointer;
        }

        .data-mode-option span {
            font-size: 14px;
            color: #7f8c8d;
        }

        .data-mode-option input[type="radio"]:checked + span {
            color: #2c3e50;
            font-weight: 500;
        }

        .data-btn.online-btn {
            color: #9b59b6;
            background: #f5eef8;
            border-color: #9b59b6;
        }

        .data-btn.online-btn:hover {
            background: #9b59b6;
            color: #fff;
        }

        /* URL Input Modal */
        .url-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .url-modal-overlay.active {
            display: flex;
        }

        .url-modal {
            background: #fff;
            border-radius: 12px;
            padding: 30px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .url-modal h4 {
            font-size: 18px;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .url-input-container {
            margin-bottom: 20px;
        }

        .url-input-container label {
            display: block;
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 8px;
        }

        .url-input-container input {
            width: 100%;
            padding: 12px 16px;
            font-size: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: #2c3e50;
            background: #f8f9fa;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            transition: border-color 0.2s ease;
        }

        .url-input-container input:focus {
            outline: none;
            border-color: #3498db;
            background: #fff;
        }

        .url-modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .url-modal-btn {
            padding: 10px 20px;
            font-size: 14px;
            font-family: inherit;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .url-modal-btn.cancel {
            background: #f8f9fa;
            border: 2px solid #ecf0f1;
            color: #7f8c8d;
        }

        .url-modal-btn.cancel:hover {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .url-modal-btn.confirm {
            background: #9b59b6;
            border: 2px solid #9b59b6;
            color: #fff;
        }

        .url-modal-btn.confirm:hover {
            background: #8e44ad;
            border-color: #8e44ad;
        }

        .url-modal-btn.confirm:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .data-textarea-container {
            margin-bottom: 20px;
        }

        .data-textarea-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .data-textarea {
            width: 100%;
            height: 200px;
            padding: 16px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.5;
            color: #2c3e50;
            background: #f8f9fa;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            resize: vertical;
            transition: border-color 0.2s ease;
        }

        .data-textarea:focus {
            outline: none;
            border-color: #3498db;
            background: #fff;
        }

        .data-textarea.error {
            border-color: #e74c3c;
            background: #fdf2f2;
        }

        .data-status {
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 15px;
            display: none;
        }

        .data-status.success {
            display: block;
            background: #e8f8f0;
            color: #27ae60;
            border: 1px solid #27ae60;
        }

        .data-status.error {
            display: block;
            background: #fdf2f2;
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .data-info {
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 15px;
        }

        .data-info p {
            font-size: 13px;
            color: #7f8c8d;
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .data-info p:last-child {
            margin-bottom: 0;
        }

        .data-info code {
            font-family: 'SF Mono', 'Consolas', monospace;
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Hidden file input */
        .hidden-file-input {
            display: none;
        }		

        /* Responsive */
        @media (max-width: 768px) {
            .settings-group {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .settings-group-label {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 8px;
                margin-bottom: 8px;
                justify-content: center;
            }
            
            .settings-group-items {
                flex-wrap: wrap;
                justify-content: center;
            }

            .selector-row {
                flex-wrap: wrap;
            }

            .selector-label {
                min-width: 100%;
                margin-bottom: 8px;
            }

            .sentence-selector-wrapper {
                flex-wrap: wrap;
            }

            .sentence-selector-wrapper .selector-dropdown,
            .sentence-filter-input,
            .type-filter-dropdown,
            .sentence-nav-controls {
                flex: 1 1 100%;
                min-width: 100%;
            }

            .sentence-nav-controls {
                justify-content: center;
                margin-top: 8px;
            }
        }

        @media (max-width: 600px) {
            .render-card {
                padding: 15px 0;
            }

            .token-classical {
                font-size: 20px;
            }

            .token-modern {
                font-size: 14px;
            }

            .token-pair {
                padding: 6px 6px;
                min-width: 40px;
            }

            .settings-panel {
                padding: 12px 16px;
            }

            .settings-grid {
                gap: 12px;
            }

            .setting-item {
                flex: 0 0 auto;
            }

            .tab-button {
                padding: 12px 16px;
                font-size: 14px;
            }

            .add-sentence-btn, .remove-sentence-btn {
                width: 32px;
                height: 32px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>文白對譯平台</h1>
            <div class="subtitle">Classical-to-Modern Chinese Parallel Translation</div>
        </div>

		<!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" data-tab="paratrans">對譯</button>
            <button class="tab-button" data-tab="data">數據</button>
            <button class="tab-button" data-tab="stats">統計</button>
            <button class="tab-button" data-tab="info">說明</button>
        </div>

        <!-- Paratrans Tab Content -->
        <div id="paratrans-tab" class="tab-content active">
            <!-- Settings Panel - New Design with Grouped Layout -->
            <div class="settings-panel">
                <div class="settings-header">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="18" height="18">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    <span class="settings-title">設定</span>
                </div>
                <div class="settings-grid">
                    <!-- Markup Group -->
                    <div class="settings-group">
                        <div class="settings-group-label">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                <line x1="7" y1="7" x2="7.01" y2="7"></line>
                            </svg>
                            標示
                        </div>
                        <div class="settings-group-items">
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleEllipsis">
                                    <span class="toggle-slider ellipsis-slider"></span>
                                </label>
                                <span class="setting-label">省譯</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleAddition">
                                    <span class="toggle-slider addition-slider"></span>
                                </label>
                                <span class="setting-label">增譯</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleParaphrase">
                                    <span class="toggle-slider paraphrase-slider"></span>
                                </label>
                                <span class="setting-label">補充文意</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleReorder">
                                    <span class="toggle-slider reorder-slider"></span>
                                </label>
                                <span class="setting-label">語序倒置</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleReconstruction">
                                    <span class="toggle-slider reconstruction-slider"></span>
                                </label>
                                <span class="setting-label">重構</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleLoan">
                                    <span class="toggle-slider loan-slider"></span>
                                </label>
                                <span class="setting-label">通假</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleArchaic">
                                    <span class="toggle-slider archaic-slider"></span>
                                </label>
                                <span class="setting-label">古今字</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Index Group -->
                    <div class="settings-group">
                        <div class="settings-group-label">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="4" y1="21" x2="4" y2="14"></line>
                                <line x1="4" y1="10" x2="4" y2="3"></line>
                                <line x1="12" y1="21" x2="12" y2="12"></line>
                                <line x1="12" y1="8" x2="12" y2="3"></line>
                                <line x1="20" y1="21" x2="20" y2="16"></line>
                                <line x1="20" y1="12" x2="20" y2="3"></line>
                                <line x1="1" y1="14" x2="7" y2="14"></line>
                                <line x1="9" y1="8" x2="15" y2="8"></line>
                                <line x1="17" y1="16" x2="23" y2="16"></line>
                            </svg>
                            索引
                        </div>
                        <div class="settings-group-items">
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleIndex">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span class="setting-label">詞序編號</span>
                            </div>
                        </div>
                    </div>

                    <!-- Interaction Group -->
                    <div class="settings-group">
                        <div class="settings-group-label">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                                <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                            </svg>
                            互動
                        </div>
                        <div class="settings-group-items">
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleMultiHighlight">
                                    <span class="toggle-slider multi-highlight-slider"></span>
                                </label>
                                <span class="setting-label">多重高亮</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleShowClassical" checked>
                                    <span class="toggle-slider classical-slider"></span>
                                </label>
                                <span class="setting-label">顯示文言</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleShowModern" checked>
                                    <span class="toggle-slider modern-slider"></span>
                                </label>
                                <span class="setting-label">顯示白話</span>
                            </div>
                            <div class="setting-item">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleHint" checked>
                                    <span class="toggle-slider hint-slider"></span>
                                </label>
                                <span class="setting-label">提示</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sentence Blocks Container -->
            <div class="sentence-blocks-container" id="sentenceBlocksContainer">
                <!-- Sentence blocks will be dynamically added here -->
            </div>

            <!-- Legend Card - Separate Section -->
            <div class="legend-card">
                <div class="legend">
                    <h3>對應類型圖例</h3>
                    <!-- Row 1: Natural -->
                    <div class="legend-row">
                        <div class="legend-item">
                            <span class="legend-symbol natural">""</span>
                            <span class="legend-label">自然對應 (Natural Correspondence)</span>
                        </div>
                    </div>
                    <!-- Row 2: Ellipsis, Addition, Paraphrase -->
                    <div class="legend-row">
                        <div class="legend-item">
                            <span class="legend-symbol ellipsis">〈〉</span>
                            <span class="legend-label">省譯 (Ellipsis)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-symbol addition">（）</span>
                            <span class="legend-label">增譯 (Addition)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-symbol paraphrase">#</span>
                            <span class="legend-label">文意 (Contextual Meaning)</span>
                        </div>
                    </div>
                    <!-- Row 3: Reorder, Reconstruction -->
                    <div class="legend-row">
                        <div class="legend-item">
                            <span class="legend-symbol reorder">〔〕</span>
                            <span class="legend-label">語序倒置 (Reorder)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-symbol reconstruction">｛｝</span>
                            <span class="legend-label">重構 (Reconstruction)</span>
                        </div>
                    </div>
                    <!-- Row 4: Loan, Archaic -->
                    <div class="legend-row">
                        <div class="legend-item">
                            <span class="legend-symbol loan">「」</span>
                            <span class="legend-label">通假 (Phonetic Loan)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-symbol archaic">『』</span>
                            <span class="legend-label">古今字 (Archaic Character)</span>
                        </div>
                    </div>
                    
                    <div class="addition-subtypes" id="additionSubtypes">
                        <h4>增譯子類型說明</h4>
                        <div class="subtype-item">
                            <span class="subtype-code">3,4</span>
                            <span>插入於 c-3 與 c-4 之間（並列結構）</span>
                        </div>
                        <div class="subtype-item">
                            <span class="subtype-code">7&gt;</span>
                            <span>插入於 c-7 之後（介詞後省略賓語）</span>
                        </div>
                        <div class="subtype-item">
                            <span class="subtype-code">&lt;9</span>
                            <span>插入於 c-9 之前（省略數詞「一」）</span>
                        </div>
                    </div>

                    <div class="ellipsis-explanation" id="ellipsisExplanation">
                        <h4>省譯說明</h4>
                        <p>省譯標示用於白話翻譯中保留但標記為可省略的詞彙，通常是文言中的虛詞在現代漢語中可省略的情況。</p>
                        <div class="example">例：「而」→「〈而〉」表示連詞在白話中可省略</div>
                    </div>

                    <div class="paraphrase-explanation" id="paraphraseExplanation">
                        <h4>文意說明</h4>
                        <p>當詞彙的字面翻譯（詞義）不足以理解句意時，需要補充語境義（文意）來幫助理解。文意顯示在第三行，位於對應的白話詞彙下方。</p>
                        <div class="structure">
                            Line 1: 文言（Classical）<br>
                            Line 2: 對譯（Modern/Lexical）<br>
                            Line 3: 文意（Contextual Meaning）
                        </div>
                        <div class="example">例：「為」→「做」(詞義) →「變為」(文意)</div>
                        <p style="margin-top: 10px;"><strong>範圍式文意：</strong>當多個詞彙共同構成一個文意時，會以範圍方式標記。第一個詞彙下方顯示完整文意，後續詞彙以斜線連接表示屬於同一範圍。</p>
                        <div class="example">例：「治生商賈」→「尋找維持生活的方法」+「做生意」</div>
                    </div>

                    <div class="reorder-explanation" id="reorderExplanation">
                        <h4>語序倒置說明</h4>
                        <p>語序倒置標示用於文言與白話之間詞序不同的情況。使用〔〕括號標記白話翻譯中需要調整位置的詞彙，並以不同顏色區分不同的倒置組。</p>
                        <div class="example">例：「取之於藍」→「〔從藍草〕取得它」（介詞結構前置）</div>
                        <div class="group-colors">
                            <div class="group-color-item">
                                <span class="color-box group-a"></span>
                                <span>倒置組 A</span>
                            </div>
                            <div class="group-color-item">
                                <span class="color-box group-b"></span>
                                <span>倒置組 B</span>
                            </div>
                        </div>
                    </div>

                    <div class="reconstruction-explanation" id="reconstructionExplanation">
                        <h4>重構說明</h4>
                        <p>重構標示用於文言結構需要在白話中進行句法重組的情況。當文言的詞彙組合無法直接對應到白話時，需要重新構建句子結構。使用｛｝括號標記重構範圍。</p>
                        <div class="structure">
                            Stage 1: 重構 - 擴展文言結構為白話結構<br>
                            Stage 2: 倒置 - 在重構範圍內調整語序（如有需要）
                        </div>
                        <div class="example">例：「仁者安仁」→「仁德的人｛〔在仁德中〕感到安心｝」</div>
                    </div>

                    <div class="loan-explanation" id="loanExplanation">
                        <h4>通假說明</h4>
                        <p>通假字是指在文言文中，借用同音或音近的字來代替本字的現象。這種現象在古籍中很常見，學習者需要識別通假字才能正確理解文意。</p>
                        <div class="example">例：「有」→「「又」」表示「有」是「又」的通假字</div>
                    </div>

                    <div class="archaic-explanation" id="archaicExplanation">
                        <h4>古今字說明</h4>
                        <p>古今字是指一個字的字形隨時代演變，古代使用的字形（古字）與後來新造或改用的字形（今字）不同。在閱讀古籍時，需要用今字來理解古字的意義。</p>
                        <div class="example">例：「暴」→「『曬乾』」表示「暴」是「曝」的古字，意為曬乾</div>
                    </div>

                    <div class="index-legend" id="indexLegend">
                        <div class="index-legend-item">
                            <span class="sample classical">c-0</span>
                            <span>文言詞序 (Classical Index)</span>
                        </div>
                        <div class="index-legend-item">
                            <span class="sample modern">m-0</span>
                            <span>白話詞序 (Modern Index)</span>
                        </div>
                        <div class="index-legend-item">
                            <span class="sample addition">3,4</span>
                            <span>增譯錨點 (Addition Anchor)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

<!-- Data Tab Content -->
<!-- Data Tab Content -->
        <div id="data-tab" class="tab-content">
            <div class="data-card">
                <div class="data-section">
                    <h3>數據管理 Data Management</h3>
                    
                    <!-- Data Mode Radio Buttons -->
                    <div class="data-mode-section">
                        <span class="data-mode-label">載入模式 Load Mode:</span>
                        <div class="data-mode-options">
                            <label class="data-mode-option">
                                <input type="radio" name="dataMode" value="replace" checked>
                                <span>取代數據 Replace</span>
                            </label>
                            <label class="data-mode-option">
                                <input type="radio" name="dataMode" value="append">
                                <span>追加數據 Append</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="data-buttons">
                        <button class="data-btn sample-btn" onclick="loadSampleData()">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10 9 9 9 8 9"></polyline>
                            </svg>
                            載入內建範例數據
                        </button>
                        <button class="data-btn load-btn" onclick="triggerFileLoad()">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            載入外部數據檔案
                        </button>
                        <button class="data-btn online-btn" onclick="showUrlModal()">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="2" y1="12" x2="22" y2="12"></line>
                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                            </svg>
                            載入網絡數據
                        </button>
                        <input type="file" id="fileInput" class="hidden-file-input" accept=".txt,.js,.json" onchange="handleFileLoad(event)">
                    </div>
                </div>

                <div class="data-section">
                    <div class="data-textarea-container">
                        <label class="data-textarea-label">篇章數據 Chapters Data</label>
                        <textarea id="chaptersTextarea" class="data-textarea" placeholder="const chapters = [
    { id: &quot;...&quot;, name: &quot;...&quot;, book: &quot;...&quot;, chapter: &quot;...&quot;, author: &quot;...&quot;, era: &quot;...&quot; },
];">
						</textarea>
                    </div>

                    <div class="data-textarea-container">
                        <label class="data-textarea-label">句子數據 Sentences Data</label>
                        <textarea id="sentencesTextarea" class="data-textarea" placeholder="const sentencesByChapter = {
    &quot;chapterId&quot;: [
        { id: &quot;...&quot;, classical: [...], modern: [...], alignments: [...] }
    ],
};">
						</textarea>
                    </div>

                    <div class="data-buttons">
                        <button class="data-btn apply-btn" onclick="applyTextareaData()">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            套用數據 Apply
                        </button>
                    </div>

                    <div id="dataStatus" class="data-status"></div>
                </div>

                <div class="data-section">
                    <h3>數據格式說明 Data Format</h3>
                    <div class="data-info">
                        <p><strong>篇章數據格式：</strong></p>
                        <p><code>const chapters = [ { id: "chapterId", name: "篇章名", book: "書名", chapter: "章節", author: "作者", era: "時代" }, ... ];</code></p>
                        <p><strong>句子數據格式：</strong></p>
                        <p><code>const sentencesByChapter = { "chapterId": [ { id: "句子ID", classical: ["詞1", "詞2", ...], modern: ["譯1", "譯2", ...], alignments: [[cIdx, mIdx, "類型"], ...] }, ... ], ... };</code></p>
                        <p><strong>外部檔案格式：</strong>可載入 <code>.txt</code> 或 <code>.js</code> 檔案，檔案內容應包含 <code>const chapters = [...];</code> 和 <code>const sentencesByChapter = {...};</code> 兩個變數定義。</p>
                        <p><strong>載入模式：</strong>「取代數據」會清空現有數據後載入新數據；「追加數據」會將新數據加到現有數據後面（重複的篇章ID會被跳過）。</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- URL Input Modal -->
        <div class="url-modal-overlay" id="urlModalOverlay" onclick="hideUrlModal(event)">
            <div class="url-modal" onclick="event.stopPropagation()">
                <h4>載入網絡數據 Load Online Data</h4>
                <div class="url-input-container">
                    <label>請輸入數據檔案的網址 Enter data file URL:</label>
                    <input type="text" id="urlInput" placeholder="https://example.com/data.txt" value="https://jwilam.github.io/paratranslation/data/pt_data_test_1.txt">
                </div>
                <div class="url-modal-buttons">
                    <button class="url-modal-btn cancel" onclick="hideUrlModal()">取消 Cancel</button>
                    <button class="url-modal-btn confirm" id="urlConfirmBtn" onclick="loadOnlineData()">載入 Load</button>
                </div>
            </div>
        </div>

        <!-- Statistics Tab Content -->
        <div id="stats-tab" class="tab-content">
            <div class="stats-card" id="statsContainer">
                <!-- Statistics will be dynamically rendered here -->
            </div>
        </div>

        <!-- Info Tab Content -->
        <div id="info-tab" class="tab-content">
            <div class="info-card">
                <div class="info-section">
                    <h2>平台簡介</h2>
                    <p>本平台為文言文（古典漢語）與白話文（現代漢語）的對譯學習工具，透過詞彙層級的對齊標注，幫助學習者理解文言文與白話文之間的對應關係。</p>
                </div>

                <div class="info-section">
                    <h2>對譯原理：文白一貫</h2>
                    
                    <div class="info-box principle">
                        <h4>文白一貫原理</h4>
                        <p>文言文與白話文的語法結構具有高度相似性，這種結構一致性稱為「文白一貫原理」。由於語法結構相近，在大多數情況下，逐詞翻譯文言文的詞義（lexical meaning）便足以理解整個句子的意思。這就是平行翻譯的基礎。</p>
                    </div>

                    <p>然而，文言文與白話文之間始終存在一些有限的差異。學習文言文的核心，其實就是掌握這些差異的類型與規律。本平台透過標注系統，將這些差異明確地呈現出來，幫助學習者建立對文白差異的認識。</p>

                    <h3>差異類型總覽</h3>
                    <ul>
                        <li><strong>增譯</strong>：白話中需要補充文言原文沒有明確表達的詞彙</li>
                        <li><strong>省譯</strong>：文言中的虛詞在白話中可省略</li>
                        <li><strong>文意</strong>：詞義翻譯不足以理解句意，需要補充語境義</li>
                        <li><strong>語序倒置</strong>：文言與白話的詞序不同</li>
                        <li><strong>重構</strong>：文言結構需要在白話中進行句法重組</li>
                        <li><strong>通假</strong>：借用同音字代替本字</li>
                        <li><strong>古今字</strong>：古代字形與現代字形的對應</li>
                    </ul>
                </div>

                <div class="info-section">
                    <h2>互動操作說明</h2>
                    <p>本平台提供四種高亮方式，幫助學習者理解詞彙對應關係：</p>

                    <h3>1. 懸停高亮（Hover Highlight）</h3>
                    <p>將滑鼠移至任一詞彙上，會高亮顯示該詞彙及其完整的詞義翻譯。對於重構類型（如「師」→「以…為老師」），會高亮所有相關的白話詞彙。滑鼠移開後自動取消高亮。此功能適合快速預覽詞彙對應關係。</p>

                    <h3>2. 單一點擊高亮（Single Click Highlight）</h3>
                    <p>點擊詞彙可固定高亮狀態，顯示該詞彙的完整詞義翻譯。再次點擊同一詞彙或點擊其他詞彙時，會取消前一個詞彙的高亮。此模式確保畫面上始終只有一個詞彙被高亮，適合專注觀察單一詞彙的對應關係。</p>

                    <h3>3. 多重點擊高亮（Multiple Click Highlight）</h3>
                    <p>開啟「多重高亮」開關後，點擊新詞彙時不會取消前一個詞彙的高亮，可同時高亮多個詞彙進行比較。再次點擊已高亮的詞彙可取消其高亮狀態。此模式適合教師和學習者討論時同時觀察多個詞彙。</p>

                    <div class="info-box highlight">
                        <h4>懸停與點擊高亮的特點</h4>
                        <p>懸停與點擊高亮都是針對<strong>詞義</strong>（lexical meaning）的高亮，會顯示一個文言詞彙對應的所有白話翻譯詞彙。例如，對於重構句「吾師道也」中的「師」，高亮會顯示「以」「為」「老師」三個詞彙，因為這是「師」的完整詞義翻譯。</p>
                    </div>

                    <h3>4. 按鈕高亮（Button Highlight）</h3>
                    <p>設定面板「標示」區塊中的七個開關可開啟各類型的<strong>結構</strong>高亮。與懸停/點擊高亮不同，按鈕高亮顯示的是整個語法結構，而非單一詞彙的詞義。例如，開啟「重構」開關後，會高亮顯示整個重構框架內的所有詞彙，包括框架內的其他詞彙。</p>

                    <div class="info-box reconstruction">
                        <h4>詞義高亮 vs 結構高亮</h4>
                        <p><strong>詞義高亮</strong>（懸停/點擊）：顯示一個文言詞的所有白話翻譯<br>
                        <strong>結構高亮</strong>（按鈕）：顯示整個語法結構（如重構框架、倒置組）的所有成員</p>
                    </div>

                    <h3>其他功能</h3>
                    <ul>
                        <li><strong>顯示詞序編號</strong>：開啟後顯示文言（c-）與白話（m-）的詞序編號，以及增譯和語序倒置的技術標記（如 ∅ 符號），方便追蹤對應關係。</li>
                        <li><strong>新增句例</strong>：點擊句例選擇器旁的 + 按鈕，可新增額外的句例進行比較，可跨篇章選擇。</li>
                        <li><strong>隱藏文言/白話</strong>：可隱藏文言或白話詞彙，用於默寫練習。隱藏時詞彙會在懸停或點擊時顯示。</li>
                        <li><strong>提示</strong>：開啟後在句子資訊區顯示該句子包含的對譯策略類型提示。</li>
                    </ul>
                </div>

                <!-- Credits Section -->
                <div class="info-section credits-section">
                    <div class="credits-header">
                        <h2 id="creditsTitle">鳴謝</h2>
                        <button class="lang-toggle-btn" id="langToggleBtn" onclick="toggleCreditsLanguage()">English</button>
                    </div>
                    
                    <!-- Chinese Content -->
                    <div class="credits-content active" id="credits-zh">
                        <div class="credits-grid">
                            <div class="credits-item">
                                <div class="label">設計者</div>
                                <div class="value">林葦葉、巢偉儀 (香港大學)</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">開發者</div>
                                <div class="value">Claude-Opus 4.5 (Anthropic)</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">日期</div>
                                <div class="value">2025年12月13日</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">版本</div>
                                <div class="value">48</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">理論框架</div>
                                <div class="value">文白對譯 Classical to Chinese Parallel Translation</div>
                            </div>
                        </div>
                        
                        <div class="license-box">
                            <h4>授權與引用</h4>
                            <p>本應用程式免費提供予教育及研究用途。</p>
                            <p>如您在研究或教學中使用本應用程式，請引用：</p>
                            <div class="citation">
                                林葦葉、巢偉儀 (2025)。《文白對譯平台》(版本 48.0) [網頁應用程式]。香港大學。基於林偉業 (2016)。《對譯—文言作品的教學策略》。
                            </div>
                        </div>
                        
                        <div class="contact-box">
                            <h4>回饋與支援</h4>
                            <p>如有問題、錯誤報告、功能建議或合作機會，請聯絡：</p>
                            <p>📧 官方電郵：<a href="mailto:jwilam@hku.hk">jwilam@hku.hk</a></p>
                            <p>📧 個人電郵：<a href="mailto:jwilam@gmail.com">jwilam@gmail.com</a></p>
                            <p>歡迎您的回饋以改進本平台！報告錯誤、建議功能或分享您的使用案例。</p>
                        </div>
                    </div>
                    
                    <!-- English Content -->
                    <div class="credits-content" id="credits-en">
                        <div class="credits-grid">
                            <div class="credits-item">
                                <div class="label">Designer</div>
                                <div class="value">LAM Wai Ip, CHOU, Wai Yi (HKU)</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">Developer</div>
                                <div class="value">Claude-Opus 4.5 (Anthropic)</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">Date</div>
                                <div class="value">December 13, 2025</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">Version</div>
                                <div class="value">48</div>
                            </div>
                            <div class="credits-item">
                                <div class="label">Theoretical Framework</div>
                                <div class="value">文白對譯 Classical to Chinese Parallel Translation</div>
                            </div>
                        </div>
                        
                        <div class="license-box">
                            <h4>License & Citation</h4>
                            <p>This application is provided free of charge for educational and research purposes.</p>
                            <p>If you use this application in your research or teaching, please cite:</p>
                            <div class="citation">
                                Lam, W. I., Chou, W.Y. (2025). Classical to Chinese Parallel Translation Platform (Version 48.0) [Web Application]. The University of Hong Kong. Based on LAM, W.I. (2016). 對譯—文言作品的教學策略.
                            </div>
                        </div>
                        
                        <div class="contact-box">
                            <h4>Feedback & Support</h4>
                            <p>For questions, bug reports, feature requests, or collaboration opportunities, please contact:</p>
                            <p>📧 Official: <a href="mailto:jwilam@hku.hk">jwilam@hku.hk</a></p>
                            <p>📧 Personal: <a href="mailto:jwilam@gmail.com">jwilam@gmail.com</a></p>
                            <p>We welcome your feedback to improve this platform! Report bugs, suggest features, or share your use cases.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Credits language toggle
        let creditsLanguage = 'zh';
        
        function toggleCreditsLanguage() {
            creditsLanguage = creditsLanguage === 'zh' ? 'en' : 'zh';
            
            const zhContent = document.getElementById('credits-zh');
            const enContent = document.getElementById('credits-en');
            const toggleBtn = document.getElementById('langToggleBtn');
            const title = document.getElementById('creditsTitle');
            
            if (creditsLanguage === 'zh') {
                zhContent.classList.add('active');
                enContent.classList.remove('active');
                toggleBtn.textContent = 'English';
                title.textContent = '鳴謝';
            } else {
                zhContent.classList.remove('active');
                enContent.classList.add('active');
                toggleBtn.textContent = '中文';
                title.textContent = 'Credits';
            }
        }

        // Chapter data structure
        const chapters = [
            { id: "analects", name: "論仁", book: "論語", chapter: "里仁", author: "孔門子弟", era: "先秦" },
            { id: "quanxue", name: "勸學", book: "荀子", chapter: "勸學", author: "荀子", era: "先秦" },
            { id: "hanxin", name: "淮陰侯列傳", book: "史記", chapter: "淮陰侯列傳", author: "司馬遷", era: "漢" }, 
            { id: "memorial", name: "出師表", book: "三國志", chapter: "出師表", author: "諸葛亮", era: "魏晉" },
            { id: "mentoring", name: "師說", book: "昌黎先生集", chapter: "師說", author: "韓愈", era: "唐" },
        ];

        // Type filter options
        const typeFilterOptions = [
            { value: "", label: "全部" },
            { value: "natural", label: "一貫" },
            { value: "-", label: "〈省譯〉" },
            { value: "+", label: "（增譯）" },
            { value: "#", label: "＃文意＃" },
            { value: "^", label: "［倒置］" },
            { value: "x", label: "｛重構｝" },
            { value: "~", label: "「通假」" },
            { value: "*", label: "『古今』" }
        ];

        // C2MPT Data
        const sentencesByChapter = {

            "quanxue": [
                {
                    "id": "xunzi-quanxue-001",
                    "classical": ["君子", "曰", "：", "學", "不", "可以", "已", "。"],
                    "modern": ["道德高尚的人", "說", "：", "學習", "不", "可以", "停止", "。"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [2, 2, ""], [3, 3, ""], [4, 4, ""], [5, 5, ""], [6, 6, ""], [7, 7, ""]],
                    "comment": "文白一貫句例"
                },
                {
                    "id": "xunzi-quanxue-002",
                    "classical": ["故", "不", "積", "跬", "步", "，", "無", "以", "至", "千", "里", "；"],
                    "modern": ["因此", "不", "積累", "半步", "、", "一步", "，", "沒有", "用", "任何辦法", "到", "一", "千", "里", "；"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [2, 2, ""], [3, 3, ""], ["3,4", 4, "+"], [4, 5, ""], [5, 6, ""], [6, 7, ""], [7, 8, ""], ["7>", 9, "+"], [8, 10, ""], ["<9", 11, "+"], [9, 12, ""], [10, 13, ""], [11, 14, ""]],
                    "comment": "對譯策略 2：增譯句例"
                },
                {
                    "id": "xunzi-quanxue-003",
                    "classical": ["吾", "嘗", "終", "日", "而", "思", "矣", "，"],
                    "modern": ["我", "曾經", "由", "一天", "開始到結束", "而", "思考", "了", "，"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [2, 2, "x", {frame: 1}], [3, 3, ""], [2, 4, "x", {frame: 1}], [4, 5, "-"], [5, 6, ""], [6, 7, ""], [7, 8, ""]],
                    "comment": "對譯策略 1：省譯句例"
                },
                {
                    "id": "xunzi-quanxue-004",
                    "classical": ["冰", "，", "水", "為", "之"],
                    "modern": ["冰", "，", "水", "做", "它"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [2, 2, ""], [3, 3, "#", { note: "變為" }], [4, 4, ""]],
                    "comment": "對譯策略 3：補充文意句例（原子式）"
                },
                {
                    "id": "xunzi-quanxue-005",
                    "classical": ["青", "，", "取", "之", "於", "藍", "，", "而", "青", "於", "藍", "；"],
                    "modern": ["藍色", "，", "從", "藍草", "取得", "它", "，", "卻", "比", "藍草", "藍", "；"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [4, 2, "^", { group: "A" }], [5, 3, "^", { group: "A" }], [2, 4, ""], [3, 5, ""], [6, 6, ""], [7, 7, ""], [9, 8, "^", { group: "B" }], [10, 9, "^", { group: "B" }], [8, 10, ""], [11, 11, ""]],
                    "comment": "對譯策略 4：語序倒置句例"
                },
                {
                    "id": "xunzi-quanxue-006",
                    "classical": ["順", "風", "而", "呼", "，", "聲", "非", "加", "疾", "也", "，"],
                    "modern": ["沿着", "風", "而", "叫喊", "，", "聲音", "不是", "是", "增加", "急速", "，"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [2, 2, "-"], [3, 3, ""], [4, 4, ""], [5, 5, ""], [6, 6, ""], [9, 7, "^-", { group: "A" }], [7, 8, ""], [8, 9, "#", { note: "高昂" }], [10, 10, ""]],
                    "comment": "多重對譯策略句例"
                },
                {
                    "id": "xunzi-quanxue-007",
                    "classical": ["雖", "有", "槁", "暴", "、", "不", "復", "挺", "者", "，"],
                    "modern": ["即使", "又", "枯乾", "、", "曬乾", "，", "不", "再", "伸直", "呢", "，"],
                    "alignments": [
                        [0, 0, ""],
                        [1, 1, "~"],
                        [2, 2, ""],
                        ["2,3", 3, "+"],
                        [3, 4, "*"],
                        [4, 5, ""],
                        [5, 6, ""],
                        [6, 7, ""],
                        [7, 8, ""],
                        [8, 9, "#", { note: "的原因" }],
                        [9, 10, ""]
                    ],
                    "comment": "對譯策略 6 及 7：標示通假及古今字句例"
                }
            ],
			
            "memorial": [
                {
                    "id": "memorial-001",
                    "classical": ["先帝", "創業", "未", "半", "而", "中道", "崩殂", "。"],
                    "modern": ["先帝", "創業", "未", "過半", "而", "中途", "駕崩", "。"],
                    "alignments": [[0, 0, ""], [1, 1, ""], [2, 2, ""], [3, 3, ""], [4, 4, "-"], [5, 5, ""], [6, 6, ""], [7, 7, ""]],
                    "comment": "AI自擬，非對譯句例"
                },
                {
                    "id": "memorial-002",
                    "classical": ["先", "帝", "創", "業", "未", "半", "而", "中", "道", "崩", "殂", "。"],
                    "modern": ["已經死去的", "皇帝", "開創", "事業", "還沒有", "一半", "卻", "在", "一半", "路", "上", "駕崩", "、", "死亡", "。"],
                    "alignments": [
                        [0, 0, ""],
                        [1, 1, ""],
                        [2, 2, ""],
                        [3, 3, ""],
                        [4, 4, ""],
                        [5, 5, ""],
                        [6, 6, ""],
                        ["<7", 7, "+", {scope: 1}],
                        [7, 8, "", {scope: 1}],
                        [8, 9, "", {scope: 1}],
                        ["8>", 10, "+", {scope: 1}],
                        [9, 11, "", {scope: 2}],
                        ["9,10", 12, "+", {scope: 2}],
                        [10, 13, "-", {scope: 2}],
                        [11, 14, ""]
                    ],
                    "comment": "修訂AI自擬語譯為對譯句例"
                },
            ],
			
            "analects": [
                {
                    "id": "analects-liren-001",
                    "classical": ["仁", "者", "安", "仁", "。"],
                    "modern": ["仁德", "的人", "在", "仁德", "中", "感到", "安心", "。"],
                    "alignments": [
                        [0, 0, ""],
                        [1, 1, ""],
                        [2, 5, "x", { frame: 1 }],
                        ["<3", 2, "+^", { frame: 1, group: "A" }],
                        [3, 3, "^", { frame: 1, group: "A" }],
                        ["3>", 4, "+^", { frame: 1, group: "A" }],
                        [2, 6, "x", { frame: 1 }],
                        [4, 7, ""]
                    ],
                    "comment": "對譯策略 5：重構句例"
                }
            ],
			
            "hanxin": [
                {
                    "id": "hanxin-001",
                    "classical": ["又", "不", "能", "治", "生", "商", "賈", "。"],
                    "modern": ["更", "不", "能夠", "治理", "財物", "、", "運貨買賣", "、", "囤積營利", "。"],
                    "alignments": [
                        [0, 0, ""],
                        [1, 1, ""],
                        [2, 2, ""],
                        [3, 3, "#",  { scope: 1 , note: [ 1, "尋找維持生活的方法"] }],
                        [4, 4, "#",  { scope: 1 , note: 1 } ],
                        ["4,5", 5, "+", { scope: 1 }],
                        [5, 6, "#",  { scopes: [1, 2] , note: [2, "做生意" ] }],
                        ["5,6", 7, "+#", { scope: 2 ,  note: 2  } ],
                        [6, 8, "#", { scope: 2 ,  note: 2  }],
                        [7, 9, ""]
                    ],
                    "comment": "對譯策略 2：增譯句例（含樞紐詞）+ 範圍式文意"
                }
            ],
			
            "mentoring": [
                {
                    "id": "mentoring-001",
                    "classical": ["吾", "師", "道", "也", "。"],
                    "modern": ["我", "是", "以", "道理", "為", "老師", "。"],
                    "alignments": [
                        [0, 0, ""],
                        [3, 1, "^", {group: "A"} ],
                        [1, 2, "x", { frame: 1 }],
                        [2, 3, "", { frame: 1 }],
                        [1, 4, "x", { frame: 1 }],
                        [1, 5, "x", { frame: 1 }],
                        [4, 6, ""]
                    ],
                    "comment": "對譯策略 5：重構句例"
                }
            ]
        };

        const typeConfig = {
            "": { name: "自然對應", class: "type-natural", symbol: '""', pairClass: "" },
            "+": { name: "增譯", class: "type-addition", symbol: "+", pairClass: "type-addition" },
            "-": { name: "省譯", class: "type-ellipsis", symbol: "〈〉", pairClass: "type-ellipsis" },
            "#": { name: "文意", class: "type-paraphrase", symbol: "#", pairClass: "type-paraphrase" },
            "^": { name: "語序倒置", class: "type-reorder", symbol: "^", pairClass: "type-reorder" },
            "x": { name: "重構", class: "type-reconstruction", symbol: "｛｝", pairClass: "type-reconstruction" },
            "~": { name: "通假", class: "type-loan", symbol: "「」", pairClass: "type-loan" },
            "*": { name: "古今字", class: "type-archaic", symbol: "『』", pairClass: "type-archaic" }
        };

        let showIndex = false;
        let enhanceAddition = false;
        let enhanceEllipsis = false;
        let enhanceParaphrase = false;
        let enhanceReorder = false;
        let enhanceReconstruction = false;
        let enhanceLoan = false;
        let enhanceArchaic = false;
        let multiHighlightMode = false;
        let showClassicalTokens = true;
        let showModernTokens = true;
        let showHint = true;
        
        let sentenceBlocks = [{ id: 0, chapterId: "hanxin", sentenceIndex: 0, filterText: "", typeFilter: "" }];
        let nextBlockId = 1;

        let alignmentPairMaps = {};
        let additionTriggerMaps = {};
        let frameMaps = {};
        let lexicalMeaningMaps = {};
        let scopeMaps = {};
        let additionScopeMaps = {};
        let tokenScopeMaps = {};
        let paraphraseRangeMaps = {};

        function getChapterById(chapterId) {
            return chapters.find(c => c.id === chapterId) || chapters[0];
        }

        function getSentencesByChapterId(chapterId) {
            return sentencesByChapter[chapterId] || [];
        }

        function deriveRawFromTokens(tokens) {
            return tokens.join('');
        }

        function isPunctuation(token) {
            const punctuationPattern = /^[，。、；：？！「」『』（）〈〉〔〕【】""''·…—\-\.,;:?!()[\]{}'"]+$/;
            return punctuationPattern.test(token);
        }

        function buildTokenDisplayWithAllBrackets(token, typeStr, reorderInfo, isLoan, isArchaic, frameInfo) {
            if (isPunctuation(token)) {
                return token;
            }
            
            let display = token;
            
            if (isLoan || hasType(typeStr, '~')) {
                display = `「${display}」`;
            }
            
            if (isArchaic || hasType(typeStr, '*')) {
                display = `『${display}』`;
            }
            
            if (hasType(typeStr, '-')) {
                display = `〈${display}〉`;
            }
            
            if (hasType(typeStr, '+')) {
                display = `（${display}）`;
            }
            
            if (hasType(typeStr, '^') && reorderInfo) {
                if (reorderInfo.isStart && reorderInfo.isEnd) {
                    display = `〔${display}〕`;
                } else if (reorderInfo.isStart) {
                    display = `〔${display}`;
                } else if (reorderInfo.isEnd) {
                    display = `${display}〕`;
                }
            }
            
            if (frameInfo) {
                if (frameInfo.isStart && frameInfo.isEnd) {
                    display = `｛${display}｝`;
                } else if (frameInfo.isStart) {
                    display = `｛${display}`;
                } else if (frameInfo.isEnd) {
                    display = `${display}｝`;
                }
            }
            
            return display;
        }

        function deriveModernRawWithLabels(data) {
            const modernTokens = data.modern;
            const alignments = data.alignments;
            
            const modernTypeMap = {};
            alignments.forEach(alignment => {
                const [cIdx, mIdx, typeStr, meta] = alignment;
                if (!modernTypeMap[mIdx]) {
                    modernTypeMap[mIdx] = { typeStr, meta, cIdx };
                }
            });
            
            const reorderGroups = {};
            alignments.forEach(alignment => {
                const [cIdx, mIdx, typeStr, meta] = alignment;
                if (hasType(typeStr, '^') && meta?.group) {
                    if (!reorderGroups[meta.group]) {
                        reorderGroups[meta.group] = [];
                    }
                    reorderGroups[meta.group].push({ mIdx, typeStr });
                }
            });
            
            const reorderPositions = {};
            Object.keys(reorderGroups).forEach(group => {
                const indices = [...new Set(reorderGroups[group].map(i => i.mIdx))].sort((a, b) => a - b);
                indices.forEach((mIdx, i) => {
                    reorderPositions[mIdx] = {
                        isStart: i === 0,
                        isEnd: i === indices.length - 1,
                        group: group
                    };
                });
            });
            
            const frameGroups = {};
            alignments.forEach(alignment => {
                const [cIdx, mIdx, typeStr, meta] = alignment;
                if (meta?.frame) {
                    if (!frameGroups[meta.frame]) {
                        frameGroups[meta.frame] = [];
                    }
                    if (!frameGroups[meta.frame].includes(mIdx)) {
                        frameGroups[meta.frame].push(mIdx);
                    }
                }
            });
            
            const framePositions = {};
            Object.keys(frameGroups).forEach(frame => {
                const indices = frameGroups[frame].sort((a, b) => a - b);
                indices.forEach((mIdx, i) => {
                    framePositions[mIdx] = {
                        isStart: i === 0,
                        isEnd: i === indices.length - 1,
                        frame: frame
                    };
                });
            });
            
            let result = '';
            
            modernTokens.forEach((token, idx) => {
                const typeInfo = modernTypeMap[idx];
                const reorderInfo = reorderPositions[idx];
                const frameInfo = framePositions[idx];
                
                if (isPunctuation(token)) {
                    result += token;
                } else if (typeInfo) {
                    result += buildTokenDisplayWithAllBrackets(
                        token, 
                        typeInfo.typeStr || '', 
                        reorderInfo,
                        false,
                        false,
                        frameInfo
                    );
                } else {
                    result += token;
                }
            });
            
            return result;
        }

        function parseParaphraseNote(note) {
            if (note === undefined || note === null) {
                return null;
            }
            
            if (typeof note === 'string') {
                return { type: 'atomic', text: note, rangeId: null };
            }
            
            if (typeof note === 'number') {
                return { type: 'range-continuation', text: null, rangeId: note };
            }
            
            if (Array.isArray(note) && note.length === 2) {
                return { type: 'range-start', text: note[1], rangeId: note[0] };
            }
            
            return null;
        }

        function deriveParaphraseRawText(data) {
            const modernTokens = data.modern;
            const alignments = data.alignments;
            
            const rangeTexts = {};
            const rangeMembers = {};
            const atomicParaphrases = {};
            
            let hasParaphrase = false;
            
            alignments.forEach(alignment => {
                const [cIdx, mIdx, typeStr, meta] = alignment;
                if (hasType(typeStr, '#') && meta?.note !== undefined) {
                    hasParaphrase = true;
                    const parsed = parseParaphraseNote(meta.note);
                    
                    if (parsed) {
                        if (parsed.type === 'atomic') {
                            atomicParaphrases[mIdx] = parsed.text;
                        } else if (parsed.type === 'range-start') {
                            rangeTexts[parsed.rangeId] = parsed.text;
                            if (!rangeMembers[parsed.rangeId]) {
                                rangeMembers[parsed.rangeId] = [];
                            }
                            rangeMembers[parsed.rangeId].push(mIdx);
                        } else if (parsed.type === 'range-continuation') {
                            if (!rangeMembers[parsed.rangeId]) {
                                rangeMembers[parsed.rangeId] = [];
                            }
                            rangeMembers[parsed.rangeId].push(mIdx);
                        }
                    }
                }
            });
            
            if (!hasParaphrase) {
                return null;
            }
            
            const usedRanges = new Set();
            let result = '';
            
            modernTokens.forEach((token, idx) => {
                // Check if this token is part of a range
                let foundRange = null;
                for (const rangeId of Object.keys(rangeMembers)) {
                    if (rangeMembers[rangeId].includes(idx)) {
                        foundRange = rangeId;
                        break;
                    }
                }
                
                if (foundRange !== null) {
                    if (!usedRanges.has(foundRange)) {
                        // First token in range - show paraphrase text
                        result += `<span class="paraphrase-highlight">#${rangeTexts[foundRange]}#</span>`;
                        usedRanges.add(foundRange);
                    }
                    // Subsequent tokens in range - skip (they're replaced by the paraphrase)
                    // This includes punctuation that is part of the range
                } else if (atomicParaphrases[idx]) {
                    result += `<span class="paraphrase-highlight">#${atomicParaphrases[idx]}#</span>`;
                } else if (isPunctuation(token)) {
                    result += token;
                } else {
                    result += token;
                }
            });
            
            return result;
        }

        function sentenceHasParaphrase(data) {
            return data.alignments.some(a => hasType(a[2], '#') && a[3]?.note !== undefined);
        }

        function getSentenceTypeHints(data) {
            const hints = [];
            const typeLabels = {
                '-': '省譯',
                '+': '增譯',
                '#': '文意',
                '^': '倒置',
                'x': '重構',
                '~': '通假',
                '*': '古今'
            };
            
            const foundTypes = new Set();
            data.alignments.forEach(alignment => {
                const typeStr = alignment[2] || '';
                for (const char of typeStr) {
                    if (typeLabels[char]) {
                        foundTypes.add(char);
                    }
                }
            });
            
            const order = ['-', '+', '#', '^', 'x', '~', '*'];
            order.forEach(type => {
                if (foundTypes.has(type)) {
                    hints.push(typeLabels[type]);
                }
            });
            
            return hints;
        }

        function parseTypes(typeStr) {
            if (!typeStr || typeStr === '') return [];
            const types = [];
            for (const char of typeStr) {
                if (typeConfig[char]) {
                    types.push(char);
                }
            }
            return types;
        }

        function hasType(typeStr, type) {
            return typeStr && typeStr.includes(type);
        }

        function parseAnchorRef(ref) {
            if (typeof ref === 'number') {
                return { type: 'normal', index: ref, display: `c-${ref}`, triggers: [ref] };
            }
            const refStr = String(ref);
            if (refStr.includes(',')) {
                const parts = refStr.split(',');
                return { type: 'between', before: parseInt(parts[0]), after: parseInt(parts[1]), display: refStr, triggers: [parseInt(parts[0]), parseInt(parts[1])] };
            }
            if (refStr.includes('>')) {
                const index = parseInt(refStr.replace('>', ''));
                return { type: 'after', index: index, display: refStr, triggers: [index] };
            }
            if (refStr.includes('<')) {
                const index = parseInt(refStr.replace('<', ''));
                return { type: 'before', index: index, display: refStr, triggers: [index] };
            }
            return { type: 'normal', index: parseInt(refStr), display: `c-${refStr}`, triggers: [parseInt(refStr)] };
        }

        function sentenceHasType(sentence, typeFilter) {
            if (!typeFilter || typeFilter === "") return true;
            
            if (typeFilter === "natural") {
                return sentence.alignments.every(a => {
                    const typeStr = a[2] || "";
                    return typeStr === "";
                });
            }
            
            return sentence.alignments.some(a => {
                const typeStr = a[2] || "";
                return typeStr.includes(typeFilter);
            });
        }

        function getScopesFromMeta(meta) {
            if (!meta) return [];
            if (meta.scopes && Array.isArray(meta.scopes)) {
                return meta.scopes;
            }
            if (meta.scope !== undefined) {
                return [meta.scope];
            }
            return [];
        }

        function computeSlotPositions(data, blockId) {
            const classicalTokens = data.classical;
            const modernTokens = data.modern;
            const alignments = data.alignments;

            alignmentPairMaps[blockId] = {};
            additionTriggerMaps[blockId] = {};
            frameMaps[blockId] = {};
            lexicalMeaningMaps[blockId] = {};
            scopeMaps[blockId] = {};
            additionScopeMaps[blockId] = {};
            tokenScopeMaps[blockId] = {};
            paraphraseRangeMaps[blockId] = {};

            const allAlignments = alignments.map((alignment, idx) => {
                const [cIdx, mIdx, typeStr, meta] = alignment;
                return { cIdx, mIdx, typeStr, meta, originalIdx: idx };
            });

            allAlignments.sort((a, b) => a.mIdx - b.mIdx);

            const naturalAlignments = [];
            const reorderGroups = {};

            const frameInfoMap = {};
            allAlignments.forEach((alignment) => {
                const { mIdx, meta } = alignment;
                if (meta?.frame) {
                    if (!frameInfoMap[meta.frame]) {
                        frameInfoMap[meta.frame] = new Set();
                    }
                    frameInfoMap[meta.frame].add(mIdx);
                }
            });

            Object.keys(frameInfoMap).forEach(frame => {
                frameInfoMap[frame] = [...frameInfoMap[frame]].sort((a, b) => a - b);
            });

            Object.keys(frameInfoMap).forEach(frame => {
                frameInfoMap[frame].forEach(mIdx => {
                    if (!frameMaps[blockId][`m-${mIdx}`]) {
                        frameMaps[blockId][`m-${mIdx}`] = [];
                    }
                    frameInfoMap[frame].forEach(otherMIdx => {
                        if (otherMIdx !== mIdx && !frameMaps[blockId][`m-${mIdx}`].includes(`m-${otherMIdx}`)) {
                            frameMaps[blockId][`m-${mIdx}`].push(`m-${otherMIdx}`);
                        }
                    });
                });
            });

            const paraphraseRangeInfoMap = {};
            allAlignments.forEach((alignment) => {
                const { mIdx, typeStr, meta } = alignment;
                if (hasType(typeStr, '#') && meta?.note !== undefined) {
                    const parsed = parseParaphraseNote(meta.note);
                    if (parsed && parsed.rangeId !== null) {
                        if (!paraphraseRangeInfoMap[parsed.rangeId]) {
                            paraphraseRangeInfoMap[parsed.rangeId] = { members: [], text: null };
                        }
                        paraphraseRangeInfoMap[parsed.rangeId].members.push(mIdx);
                        if (parsed.type === 'range-start') {
                            paraphraseRangeInfoMap[parsed.rangeId].text = parsed.text;
                        }
                    }
                }
            });

            Object.keys(paraphraseRangeInfoMap).forEach(rangeId => {
                const rangeInfo = paraphraseRangeInfoMap[rangeId];
                rangeInfo.members.forEach(mIdx => {
                    if (!paraphraseRangeMaps[blockId][`m-${mIdx}`]) {
                        paraphraseRangeMaps[blockId][`m-${mIdx}`] = [];
                    }
                    paraphraseRangeMaps[blockId][`m-${mIdx}`].push({
                        rangeId: rangeId,
                        allMembers: rangeInfo.members,
                        text: rangeInfo.text
                    });
                });
            });

            const scopeInfoMap = {};
            allAlignments.forEach((alignment) => {
                const { cIdx, mIdx, typeStr, meta } = alignment;
                const scopes = getScopesFromMeta(meta);
                
                scopes.forEach(scopeId => {
                    if (!scopeInfoMap[scopeId]) {
                        scopeInfoMap[scopeId] = {
                            members: [],
                            additions: [],
                            anchors: []
                        };
                    }
                    if (!scopeInfoMap[scopeId].members.includes(mIdx)) {
                        scopeInfoMap[scopeId].members.push(mIdx);
                    }
                    
                    if (!tokenScopeMaps[blockId][`m-${mIdx}`]) {
                        tokenScopeMaps[blockId][`m-${mIdx}`] = [];
                    }
                    if (!tokenScopeMaps[blockId][`m-${mIdx}`].includes(scopeId)) {
                        tokenScopeMaps[blockId][`m-${mIdx}`].push(scopeId);
                    }
                    
                    if (hasType(typeStr, '+')) {
                        if (!scopeInfoMap[scopeId].additions.includes(mIdx)) {
                            scopeInfoMap[scopeId].additions.push(mIdx);
                        }
                        if (!additionScopeMaps[blockId][`m-${mIdx}`]) {
                            additionScopeMaps[blockId][`m-${mIdx}`] = [];
                        }
                        if (!additionScopeMaps[blockId][`m-${mIdx}`].includes(scopeId)) {
                            additionScopeMaps[blockId][`m-${mIdx}`].push(scopeId);
                        }
                    } else if (typeof cIdx === 'number') {
                        if (!scopeInfoMap[scopeId].anchors.includes(cIdx)) {
                            scopeInfoMap[scopeId].anchors.push(cIdx);
                        }
                    }
                });
            });

            Object.keys(scopeInfoMap).forEach(scopeId => {
                const scopeInfo = scopeInfoMap[scopeId];
                scopeInfo.members.forEach(mIdx => {
                    if (!scopeMaps[blockId][`m-${mIdx}`]) {
                        scopeMaps[blockId][`m-${mIdx}`] = [];
                    }
                    scopeMaps[blockId][`m-${mIdx}`].push({
                        scopeId: scopeId,
                        allMembers: scopeInfo.members,
                        anchors: scopeInfo.anchors,
                        additions: scopeInfo.additions
                    });
                });
                scopeInfo.anchors.forEach(cIdx => {
                    if (!scopeMaps[blockId][`c-${cIdx}`]) {
                        scopeMaps[blockId][`c-${cIdx}`] = [];
                    }
                    scopeMaps[blockId][`c-${cIdx}`].push({
                        scopeId: scopeId,
                        allMembers: scopeInfo.members,
                        anchors: scopeInfo.anchors,
                        additions: scopeInfo.additions
                    });
                });
            });

            const classicalToModernMap = {};
            allAlignments.forEach((alignment) => {
                const { cIdx, mIdx, typeStr } = alignment;
                if (typeof cIdx === 'number') {
                    if (!classicalToModernMap[cIdx]) {
                        classicalToModernMap[cIdx] = [];
                    }
                    if (!classicalToModernMap[cIdx].includes(mIdx)) {
                        classicalToModernMap[cIdx].push(mIdx);
                    }
                }
            });

            Object.keys(classicalToModernMap).forEach(cIdx => {
                const modernIndices = classicalToModernMap[cIdx];
                lexicalMeaningMaps[blockId][`c-${cIdx}`] = modernIndices;
            });

            const usedReconstructionClassical = new Set();

            allAlignments.forEach((alignment) => {
                const { cIdx, mIdx, typeStr, meta } = alignment;
                const types = parseTypes(typeStr);
                const scopes = getScopesFromMeta(meta);
                
                const isPureReorder = hasType(typeStr, '^') && !hasType(typeStr, '+') && !hasType(typeStr, 'x') && !meta?.frame;
                
                let paraphraseInfo = null;
                if (hasType(typeStr, '#') && meta?.note !== undefined) {
                    const parsed = parseParaphraseNote(meta.note);
                    if (parsed) {
                        paraphraseInfo = parsed;
                    }
                }
                
                if (isPureReorder) {
                    const group = meta?.group || 'default';
                    if (!reorderGroups[group]) {
                        reorderGroups[group] = { name: group, classical: [], modern: [] };
                    }
                    const otherTypes = types.filter(t => t !== '^');
                    reorderGroups[group].classical.push({ index: cIdx, token: classicalTokens[cIdx], mIdx: mIdx, types: types, otherTypes: otherTypes, meta: meta });
                    reorderGroups[group].modern.push({ index: mIdx, token: modernTokens[mIdx], cIdx: cIdx, types: types, otherTypes: otherTypes, meta: meta });
                    
                    alignmentPairMaps[blockId][`c-${cIdx}`] = `m-${mIdx}`;
                    alignmentPairMaps[blockId][`m-${mIdx}`] = `c-${cIdx}`;
                } else {
                    const anchorRef = hasType(typeStr, '+') ? parseAnchorRef(cIdx) : null;
                    
                    let frameInfo = null;
                    if (meta?.frame) {
                        const frameTokens = frameInfoMap[meta.frame];
                        const posInFrame = frameTokens.indexOf(mIdx);
                        frameInfo = {
                            frame: meta.frame,
                            isStart: posInFrame === 0,
                            isEnd: posInFrame === frameTokens.length - 1
                        };
                    }
                    
                    let cToken = classicalTokens[cIdx];
                    let isReconstructionDuplicate = false;
                    if (hasType(typeStr, 'x') && typeof cIdx === 'number') {
                        if (usedReconstructionClassical.has(cIdx)) {
                            cToken = '∅';
                            isReconstructionDuplicate = true;
                        } else {
                            usedReconstructionClassical.add(cIdx);
                        }
                    }
                    
                    if (hasType(typeStr, '+')) {
                        cToken = '∅';
                    }
                    
                    naturalAlignments.push({
                        cIdx, mIdx,
                        cToken: cToken,
                        mToken: modernTokens[mIdx],
                        typeStr, types, meta,
                        isAddition: hasType(typeStr, '+'),
                        isEllipsis: hasType(typeStr, '-'),
                        isLoan: hasType(typeStr, '~'),
                        isArchaic: hasType(typeStr, '*'),
                        isReconstruction: hasType(typeStr, 'x'),
                        isReconstructionDuplicate: isReconstructionDuplicate,
                        isReorder: hasType(typeStr, '^'),
                        isInFrame: !!meta?.frame,
                        hasScope: scopes.length > 0,
                        scopeIds: scopes,
                        anchorRef: anchorRef,
                        frameInfo: frameInfo,
                        paraphraseInfo: paraphraseInfo
                    });
                    
                    if (hasType(typeStr, '+') && anchorRef && scopes.length === 0) {
                        additionTriggerMaps[blockId][`m-${mIdx}`] = anchorRef.triggers.map(t => `c-${t}`);
                    }
                }
            });

            const combinedReorderGroups = {};
            naturalAlignments.forEach(nat => {
                if (nat.isReorder && nat.meta?.group) {
                    if (!combinedReorderGroups[nat.meta.group]) {
                        combinedReorderGroups[nat.meta.group] = [];
                    }
                    combinedReorderGroups[nat.meta.group].push(nat);
                }
            });
            
            Object.keys(combinedReorderGroups).forEach(group => {
                const tokens = combinedReorderGroups[group].sort((a, b) => a.mIdx - b.mIdx);
                tokens.forEach((nat, i) => {
                    nat.reorderInfo = {
                        group: group,
                        isStart: i === 0,
                        isEnd: i === tokens.length - 1
                    };
                });
            });

            naturalAlignments.sort((a, b) => a.mIdx - b.mIdx);

            Object.values(reorderGroups).forEach(group => {
                group.classical.sort((a, b) => a.index - b.index);
                group.modern.sort((a, b) => a.index - b.index);
                group.classicalInsertAfter = Math.min(...group.classical.map(t => t.index));
                group.modernInsertAfter = Math.min(...group.modern.map(t => t.index));
            });

            const reorderGroupList = Object.values(reorderGroups);

            function findNaturalByModernIdx(mIdx) {
                for (let i = 0; i < naturalAlignments.length; i++) {
                    if (naturalAlignments[i].mIdx >= mIdx) return i;
                }
                return naturalAlignments.length;
            }

            function findNaturalByClassicalIdx(cIdx) {
                for (let i = 0; i < naturalAlignments.length; i++) {
                    if (!naturalAlignments[i].isAddition && naturalAlignments[i].cIdx >= cIdx) return i;
                }
                return naturalAlignments.length;
            }

            const slotAssignments = [];
            const pendingClassicalReorder = [...reorderGroupList].sort((a, b) => a.classicalInsertAfter - b.classicalInsertAfter);
            const pendingModernReorder = [...reorderGroupList].sort((a, b) => a.modernInsertAfter - b.modernInsertAfter);

            let classicalReorderIdx = 0;
            let modernReorderIdx = 0;

            for (let natPos = 0; natPos <= naturalAlignments.length; natPos++) {
                while (modernReorderIdx < pendingModernReorder.length) {
                    const group = pendingModernReorder[modernReorderIdx];
                    const insertBeforeNatPos = findNaturalByModernIdx(group.modernInsertAfter);
                    if (insertBeforeNatPos === natPos) {
                        group.modern.forEach((item, i) => {
                            slotAssignments.push({
                                slotType: 'reorder-modern',
                                classical: null,
                                modern: { type: 'reorder', token: item.token, index: item.index, cIdx: item.cIdx, group: group.name, bracketStart: i === 0, bracketEnd: i === group.modern.length - 1, types: item.types, otherTypes: item.otherTypes, meta: item.meta }
                            });
                        });
                        modernReorderIdx++;
                    } else break;
                }

                while (classicalReorderIdx < pendingClassicalReorder.length) {
                    const group = pendingClassicalReorder[classicalReorderIdx];
                    const insertBeforeNatPos = findNaturalByClassicalIdx(group.classicalInsertAfter);
                    if (insertBeforeNatPos === natPos) {
                        group.classical.forEach((item, i) => {
                            slotAssignments.push({
                                slotType: 'reorder-classical',
                                classical: { type: 'reorder', token: item.token, index: item.index, mIdx: item.mIdx, group: group.name, bracketStart: i === 0, bracketEnd: i === group.classical.length - 1, types: item.types, otherTypes: item.otherTypes, meta: item.meta },
                                modern: null
                            });
                        });
                        classicalReorderIdx++;
                    } else break;
                }

                if (natPos < naturalAlignments.length) {
                    const nat = naturalAlignments[natPos];
                    slotAssignments.push({
                        slotType: 'natural',
                        classical: { type: 'natural', token: nat.cToken, index: nat.cIdx, isEmpty: nat.isAddition, isReconstructionDuplicate: nat.isReconstructionDuplicate, anchorRef: nat.anchorRef },
                        modern: { type: 'natural', token: nat.mToken, index: nat.mIdx, isEllipsis: nat.isEllipsis, isLoan: nat.isLoan, isArchaic: nat.isArchaic, isReconstruction: nat.isReconstruction, isInFrame: nat.isInFrame, frameInfo: nat.frameInfo, reorderInfo: nat.reorderInfo, hasScope: nat.hasScope, scopeIds: nat.scopeIds, paraphraseInfo: nat.paraphraseInfo },
                        typeStr: nat.typeStr, types: nat.types, meta: nat.meta,
                        paraphraseInfo: nat.paraphraseInfo
                    });
                }
            }

            return { slots: slotAssignments, totalSlots: slotAssignments.length, reorderGroups: reorderGroupList };
        }

        function groupSlotsForDisplay(slots, blockId) {
            const groups = [];
            let i = 0;
            const processedSlotIndices = new Set();
            
            const scopeGroupRanges = [];
            
            const slotScopeMap = new Map();
            slots.forEach((slot, idx) => {
                if (slot.slotType === 'natural' && slot.modern?.hasScope) {
                    const scopeIds = slot.modern.scopeIds || [];
                    if (scopeIds.length > 0) {
                        slotScopeMap.set(idx, new Set(scopeIds));
                    }
                }
            });
            
            const usedInScopeGroup = new Set();
            
            for (let startIdx = 0; startIdx < slots.length; startIdx++) {
                if (usedInScopeGroup.has(startIdx)) continue;
                if (!slotScopeMap.has(startIdx)) continue;
                
                const groupScopes = new Set(slotScopeMap.get(startIdx));
                const groupIndices = [startIdx];
                
                let endIdx = startIdx + 1;
                while (endIdx < slots.length) {
                    if (!slotScopeMap.has(endIdx)) break;
                    
                    const nextScopes = slotScopeMap.get(endIdx);
                    let hasOverlap = false;
                    for (const s of nextScopes) {
                        if (groupScopes.has(s)) {
                            hasOverlap = true;
                            break;
                        }
                    }
                    
                    if (hasOverlap) {
                        groupIndices.push(endIdx);
                        for (const s of nextScopes) {
                            groupScopes.add(s);
                        }
                        endIdx++;
                    } else {
                        break;
                    }
                }
                
                if (groupIndices.length > 1) {
                    scopeGroupRanges.push({
                        indices: groupIndices,
                        scopeIds: [...groupScopes]
                    });
                    groupIndices.forEach(idx => usedInScopeGroup.add(idx));
                }
            }
            
            const slotToScopeGroup = new Map();
            scopeGroupRanges.forEach((range, groupIdx) => {
                range.indices.forEach(slotIdx => {
                    slotToScopeGroup.set(slotIdx, groupIdx);
                });
            });
            
            const paraphraseGroupRanges = [];
            const slotParaphraseRangeMap = new Map();
            
            slots.forEach((slot, idx) => {
                if (slot.slotType === 'natural' && slot.paraphraseInfo) {
                    const rangeId = slot.paraphraseInfo.rangeId;
                    if (rangeId !== null) {
                        if (!slotParaphraseRangeMap.has(rangeId)) {
                            slotParaphraseRangeMap.set(rangeId, []);
                        }
                        slotParaphraseRangeMap.get(rangeId).push(idx);
                    }
                }
            });
            
            slotParaphraseRangeMap.forEach((indices, rangeId) => {
                if (indices.length > 1) {
                    paraphraseGroupRanges.push({
                        indices: indices,
                        rangeId: rangeId
                    });
                }
            });
            
            const slotToParaphraseGroup = new Map();
            paraphraseGroupRanges.forEach((range, groupIdx) => {
                range.indices.forEach(slotIdx => {
                    slotToParaphraseGroup.set(slotIdx, groupIdx);
                });
            });
            
            while (i < slots.length) {
                if (processedSlotIndices.has(i)) {
                    i++;
                    continue;
                }
                
                const slot = slots[i];
                
                if (slotToScopeGroup.has(i)) {
                    const scopeGroupIdx = slotToScopeGroup.get(i);
                    const scopeRange = scopeGroupRanges[scopeGroupIdx];
                    
                    if (scopeRange.indices[0] === i) {
                        const scopeSlots = scopeRange.indices.map(idx => slots[idx]);
                        scopeRange.indices.forEach(idx => processedSlotIndices.add(idx));
                        
                        groups.push({ 
                            type: 'scope-group', 
                            scopeIds: scopeRange.scopeIds, 
                            slots: scopeSlots 
                        });
                        i = scopeRange.indices[scopeRange.indices.length - 1] + 1;
                        continue;
                    }
                }
                
                if (slotToParaphraseGroup.has(i) && !slotToScopeGroup.has(i)) {
                    const paraGroupIdx = slotToParaphraseGroup.get(i);
                    const paraRange = paraphraseGroupRanges[paraGroupIdx];
                    
                    if (paraRange.indices[0] === i) {
                        const paraSlots = paraRange.indices.map(idx => slots[idx]);
                        paraRange.indices.forEach(idx => processedSlotIndices.add(idx));
                        
                        groups.push({ 
                            type: 'paraphrase-group', 
                            rangeId: paraRange.rangeId, 
                            slots: paraSlots 
                        });
                        i = paraRange.indices[paraRange.indices.length - 1] + 1;
                        continue;
                    }
                }
                
                if (slot.slotType === 'natural' && hasType(slot.typeStr, '+') && !isPunctuation(slot.modern.token) && !slot.modern?.hasScope) {
                    const anchorRef = slot.classical.anchorRef;
                    
                    if (anchorRef.type === 'between') {
                        let beforeSlotIdx = -1;
                        for (let j = groups.length - 1; j >= 0; j--) {
                            if (groups[j].type === 'single' && groups[j].slot.slotType === 'natural' && groups[j].slot.classical.index === anchorRef.before) {
                                beforeSlotIdx = j;
                                break;
                            }
                        }
                        let afterSlotIdx = -1;
                        for (let j = i + 1; j < slots.length; j++) {
                            if (slots[j].slotType === 'natural' && !hasType(slots[j].typeStr, '+') && slots[j].classical.index === anchorRef.after) {
                                afterSlotIdx = j;
                                break;
                            }
                        }
                        if (beforeSlotIdx >= 0 && afterSlotIdx >= 0) {
                            const beforeGroup = groups.splice(beforeSlotIdx, 1)[0];
                            groups.push({ type: 'addition-group', anchorRef: anchorRef, slots: [beforeGroup.slot, slot, slots[afterSlotIdx]] });
                            processedSlotIndices.add(afterSlotIdx);
                            i++;
                            continue;
                        }
                    } else if (anchorRef.type === 'after') {
                        let triggerSlotIdx = -1;
                        for (let j = groups.length - 1; j >= 0; j--) {
                            if (groups[j].type === 'single' && groups[j].slot.slotType === 'natural' && groups[j].slot.classical.index === anchorRef.index) {
                                triggerSlotIdx = j;
                                break;
                            }
                        }
                        if (triggerSlotIdx >= 0) {
                            const triggerGroup = groups.splice(triggerSlotIdx, 1)[0];
                            groups.push({ type: 'addition-group', anchorRef: anchorRef, slots: [triggerGroup.slot, slot] });
                            i++;
                            continue;
                        }
                    } else if (anchorRef.type === 'before') {
                        let triggerSlotIdx = -1;
                        for (let j = i + 1; j < slots.length; j++) {
                            if (!processedSlotIndices.has(j) && slots[j].slotType === 'natural' && !hasType(slots[j].typeStr, '+') && slots[j].classical.index === anchorRef.index) {
                                triggerSlotIdx = j;
                                break;
                            }
                        }
                        if (triggerSlotIdx >= 0) {
                            groups.push({ type: 'addition-group', anchorRef: anchorRef, slots: [slot, slots[triggerSlotIdx]] });
                            processedSlotIndices.add(triggerSlotIdx);
                            i++;
                            continue;
                        }
                    }
                }
                
                if (slot.slotType === 'reorder-classical' || slot.slotType === 'reorder-modern') {
                    const group = slot.classical?.group || slot.modern?.group;
                    const slotDirection = slot.slotType;
                    const reorderSlots = [slot];
                    let j = i + 1;
                    while (j < slots.length) {
                        const nextSlot = slots[j];
                        if (nextSlot.slotType === slotDirection) {
                            const nextGroup = nextSlot.classical?.group || nextSlot.modern?.group;
                            if (nextGroup === group) {
                                reorderSlots.push(nextSlot);
                                j++;
                            } else break;
                        } else break;
                    }
                    groups.push({ type: 'reorder-group', group: group, direction: slotDirection, slots: reorderSlots });
                    i = j;
                    continue;
                }
                
                groups.push({ type: 'single', slot: slot });
                i++;
            }
            
            return groups;
        }

        function buildModernTokenDisplay(token, types, group, bracketStart, bracketEnd, isLoan, isArchaic, frameInfo, reorderInfo) {
            if (isPunctuation(token)) {
                return token;
            }
            
            let display = token;
            const groupClass = group === 'B' ? 'group-B' : '';
            
            if (types.includes('~') || isLoan) {
                display = `<span class="loan-bracket">「</span>${display}<span class="loan-bracket">」</span>`;
            }
            
            if (types.includes('*') || isArchaic) {
                display = `<span class="archaic-bracket">『</span>${display}<span class="archaic-bracket">』</span>`;
            }
            
            if (types.includes('-')) {
                display = `<span class="ellipsis-bracket">〈</span>${display}<span class="ellipsis-bracket">〉</span>`;
            }
            
            if (types.includes('+')) {
                display = `（${display}）`;
            }
            
            if (reorderInfo) {
                const rGroupClass = reorderInfo.group === 'B' ? 'group-B' : '';
                const startBracket = reorderInfo.isStart ? `<span class="reorder-bracket ${rGroupClass}">〔</span>` : '';
                const endBracket = reorderInfo.isEnd ? `<span class="reorder-bracket ${rGroupClass}">〕</span>` : '';
                display = `${startBracket}${display}${endBracket}`;
            } else if (types.includes('^') && !types.includes('+')) {
                const startBracket = bracketStart ? `<span class="reorder-bracket ${groupClass}">〔</span>` : '';
                const endBracket = bracketEnd ? `<span class="reorder-bracket ${groupClass}">〕</span>` : '';
                display = `${startBracket}${display}${endBracket}`;
            }
            
            if (frameInfo) {
                const startBracket = frameInfo.isStart ? `<span class="reconstruction-bracket">｛</span>` : '';
                const endBracket = frameInfo.isEnd ? `<span class="reconstruction-bracket">｝</span>` : '';
                display = `${startBracket}${display}${endBracket}`;
            }
            
            return display;
        }

        function renderTokenPair(slot, index, data, blockId) {
            const typeStr = slot.typeStr || '';
            const types = slot.types || [];
            const meta = slot.meta;
            const paraphraseInfo = slot.paraphraseInfo || slot.modern?.paraphraseInfo;
            
            let typeClasses = [];
            let hasEllipsisType = types.includes('-');
            let hasReorderType = types.includes('^');
            let hasAddition = types.includes('+');
            let hasParaphrase = types.includes('#');
            let hasLoan = types.includes('~');
            let hasArchaic = types.includes('*');
            let hasReconstruction = types.includes('x');
            let isInFrame = slot.modern?.isInFrame || meta?.frame;
            let hasScope = slot.modern?.hasScope;
            let scopeIds = slot.modern?.scopeIds || [];
            
            if (hasEllipsisType) typeClasses.push('type-ellipsis');
            if (hasReorderType) typeClasses.push('type-reorder');
            if (hasAddition) typeClasses.push('type-addition');
            if (hasParaphrase) typeClasses.push('type-paraphrase');
            if (hasLoan) typeClasses.push('type-loan');
            if (hasArchaic) typeClasses.push('type-archaic');
            if (hasReconstruction) typeClasses.push('type-reconstruction');
            if (types.length > 1) typeClasses.push('multi-type');

            const classicalHiddenClass = !showClassicalTokens ? 'hidden-token' : '';
            const modernHiddenClass = !showModernTokens ? 'hidden-token' : '';
            
            if (slot.slotType === 'reorder-classical') {
                const classical = slot.classical;
                const groupClass = classical.group === 'B' ? 'group-B' : '';
                const allTypes = classical.types || ['^'];
                
                const dataAttrs = `data-block-id="${blockId}" data-slot-type="reorder-classical" data-has-ellipsis="false" data-has-reorder="true" data-has-reconstruction="false" data-in-frame="false" data-has-loan="false" data-has-archaic="false" data-has-addition="false" data-has-scope="false" data-has-paraphrase-range="false" data-pair-id="m-${classical.mIdx}" data-self-id="c-${classical.index}" data-classical-idx="${classical.index}" data-modern-idx="${classical.mIdx}"`;
                
                const emptyVisibleClass = showIndex ? 'visible' : '';
                const connectorVisibleClass = showIndex ? 'visible' : '';
                
                return `
                    <div class="token-pair type-reorder reorder-slot ${groupClass} ${typeClasses.join(' ')}" ${dataAttrs} data-index="${index}" data-types="${allTypes.join('')}">
                        <div class="token-index classical-index ${showIndex ? 'visible' : ''}">c-${classical.index}</div>
                        <div class="token-classical ${classicalHiddenClass}">${classical.token}</div>
                        <div class="token-connector ${connectorVisibleClass}"></div>
                        <div class="token-modern reorder-empty ${groupClass} ${emptyVisibleClass}">∅</div>
                        <div class="token-index modern-index ${showIndex ? 'visible' : ''}">m-${classical.mIdx}</div>
                    </div>
                `;
            }
            
            if (slot.slotType === 'reorder-modern') {
                const modern = slot.modern;
                const groupClass = modern.group === 'B' ? 'group-B' : '';
                const allTypes = modern.types || ['^'];
                const otherTypes = modern.otherTypes || [];
                
                const hasEllipsisOther = otherTypes.includes('-');
                const dataAttrs = `data-block-id="${blockId}" data-slot-type="reorder-modern" data-has-ellipsis="${hasEllipsisOther}" data-has-reorder="true" data-has-reconstruction="false" data-in-frame="false" data-has-loan="false" data-has-archaic="false" data-has-addition="false" data-has-scope="false" data-has-paraphrase-range="false" data-pair-id="c-${modern.cIdx}" data-self-id="m-${modern.index}" data-classical-idx="${modern.cIdx}" data-modern-idx="${modern.index}"`;
                
                const modernDisplay = buildModernTokenDisplay(modern.token, allTypes, modern.group, modern.bracketStart, modern.bracketEnd, false, false, null, null);
                
                const emptyVisibleClass = showIndex ? 'visible' : '';
                const connectorVisibleClass = showIndex ? 'visible' : '';
                
                return `
                    <div class="token-pair type-reorder reorder-slot ${groupClass} ${typeClasses.join(' ')}" ${dataAttrs} data-index="${index}" data-types="${allTypes.join('')}">
                        <div class="token-index classical-index ${showIndex ? 'visible' : ''}">c-${modern.cIdx}</div>
                        <div class="token-classical reorder-empty ${groupClass} ${emptyVisibleClass}">∅</div>
                        <div class="token-connector ${connectorVisibleClass}"></div>
                        <div class="token-modern ${modernHiddenClass}">${modernDisplay}</div>
                        <div class="token-index modern-index ${showIndex ? 'visible' : ''}">m-${modern.index}</div>
                    </div>
                `;
            }
            
            const classical = slot.classical;
            const modern = slot.modern;
            
            const selfId = hasAddition ? `m-${modern.index}` : `c-${classical.index}`;
            const frameId = meta?.frame ? `frame-${meta.frame}` : '';
            const classicalIdx = typeof classical.index === 'number' ? classical.index : '';
            const scopeAttr = hasScope ? `data-scope-ids="${scopeIds.join(',')}"` : '';
            
            const hasParaphraseRange = paraphraseInfo && paraphraseInfo.rangeId !== null;
            const paraphraseRangeId = hasParaphraseRange ? paraphraseInfo.rangeId : '';
            const paraphraseRangeAttr = hasParaphraseRange ? `data-paraphrase-range-id="${paraphraseRangeId}"` : '';
            
            const dataAttrs = `data-block-id="${blockId}" data-slot-type="natural" data-has-ellipsis="${hasEllipsisType}" data-has-reorder="${hasReorderType}" data-has-reconstruction="${hasReconstruction}" data-in-frame="${!!isInFrame}" data-has-loan="${hasLoan}" data-has-archaic="${hasArchaic}" data-has-addition="${hasAddition}" data-has-scope="${hasScope}" data-has-paraphrase-range="${hasParaphraseRange}" ${scopeAttr} ${paraphraseRangeAttr} data-self-id="${selfId}" data-frame-id="${frameId}" data-classical-idx="${classicalIdx}" data-modern-idx="${modern.index}"`;
            
            let classicalIndexHtml = '';
            let anchorRefHtml = '';
            
            if (classical.isEmpty) {
                classicalIndexHtml = `<div class="token-index addition-index ${showIndex ? 'visible' : ''}">${classical.anchorRef.display}</div>`;
                anchorRefHtml = `<div class="anchor-ref ${showIndex && enhanceAddition ? 'visible' : ''}">${classical.anchorRef.display}</div>`;
            } else {
                classicalIndexHtml = `<div class="token-index classical-index ${showIndex ? 'visible' : ''}">c-${classical.index}</div>`;
            }

            const isReconstructionDuplicate = classical.isReconstructionDuplicate;
            const emptyVisibleClass = ((classical.isEmpty || isReconstructionDuplicate) && showIndex) ? 'visible' : '';
            const connectorVisibleClass = ((hasAddition || isReconstructionDuplicate) && showIndex) ? 'visible' : '';

            let modernTokenDisplay = buildModernTokenDisplay(
                modern.token, 
                types, 
                null, 
                false, 
                false, 
                modern.isLoan, 
                modern.isArchaic,
                modern.frameInfo,
                modern.reorderInfo
            );

            let paraphraseHtml = '';
            if (hasParaphrase && paraphraseInfo) {
                if (paraphraseInfo.type === 'atomic') {
                    paraphraseHtml = `
                        <div class="paraphrase-connector"></div>
                        <div class="token-paraphrase ${modernHiddenClass}"><span class="paraphrase-marker">#</span>${paraphraseInfo.text}</div>
                    `;
                } else if (paraphraseInfo.type === 'range-start') {
                    paraphraseHtml = `
                        <div class="paraphrase-connector"></div>
                        <div class="token-paraphrase ${modernHiddenClass}"><span class="paraphrase-marker">#</span>${paraphraseInfo.text}</div>
                    `;
                } else if (paraphraseInfo.type === 'range-continuation') {
                    // Default: horizontal line (—), changes to diagonal (/) on hover/highlight
                    paraphraseHtml = `
                        <div class="paraphrase-connector range-continuation"></div>
                        <div class="token-paraphrase empty-slot ${modernHiddenClass}"></div>
                    `;
                }
            }

            const reconstructionDuplicateClass = isReconstructionDuplicate ? 'reconstruction-duplicate' : '';
            const emptyClass = classical.isEmpty ? 'empty' : (isReconstructionDuplicate ? 'empty reconstruction-empty' : '');

            return `
                <div class="token-pair ${typeClasses.join(' ')} ${reconstructionDuplicateClass}" ${dataAttrs} data-index="${index}" data-types="${typeStr}">
                    ${classicalIndexHtml}
                    <div class="token-classical ${emptyClass} ${emptyVisibleClass} ${classicalHiddenClass}">${classical.token}</div>
                    <div class="token-connector ${connectorVisibleClass}"></div>
                    <div class="token-modern ${modernHiddenClass}">${modernTokenDisplay}</div>
                    ${paraphraseHtml}
                    <div class="token-index modern-index ${showIndex ? 'visible' : ''}">m-${modern.index}</div>
                    ${anchorRefHtml}
                </div>
            `;
        }

        function highlightPair(tokenPair) {
            const blockId = tokenPair.getAttribute('data-block-id');
            const blockContainer = tokenPair.closest('.sentence-block');
            const selfId = tokenPair.getAttribute('data-self-id');
            const hasAddition = tokenPair.getAttribute('data-has-addition') === 'true';
            const hasScope = tokenPair.getAttribute('data-has-scope') === 'true';
            const scopeIdsAttr = tokenPair.getAttribute('data-scope-ids');
            const scopeIds = scopeIdsAttr ? scopeIdsAttr.split(',').map(s => parseInt(s)) : [];
            const hasParaphraseRange = tokenPair.getAttribute('data-has-paraphrase-range') === 'true';
            const paraphraseRangeId = tokenPair.getAttribute('data-paraphrase-range-id');
            
            const pairId = tokenPair.getAttribute('data-pair-id');
            if (pairId && blockContainer) {
                const pairElement = blockContainer.querySelector(`[data-self-id="${pairId}"]`);
                if (pairElement) {
                    pairElement.classList.add('pair-highlighted');
                }
            }
            
            if (hasParaphraseRange && paraphraseRangeId && paraphraseRangeMaps[blockId]) {
                const rangeInfoList = paraphraseRangeMaps[blockId][selfId] || [];
                const rangeInfo = rangeInfoList.find(r => r.rangeId == paraphraseRangeId);
                
                if (rangeInfo) {
                    rangeInfo.allMembers.forEach(mIdx => {
                        const elements = blockContainer.querySelectorAll(`[data-modern-idx="${mIdx}"]`);
                        elements.forEach(el => {
                            if (el !== tokenPair) {
                                el.classList.add('paraphrase-range-highlighted');
                            }
                        });
                    });
                }
            }
            
            if (hasAddition && hasScope && scopeIds.length > 0 && scopeMaps[blockId]) {
                scopeIds.forEach(scopeId => {
                    const scopeInfoList = scopeMaps[blockId][selfId] || [];
                    const scopeInfo = scopeInfoList.find(s => s.scopeId == scopeId);
                    
                    if (scopeInfo) {
                        scopeInfo.allMembers.forEach(mIdx => {
                            const elements = blockContainer.querySelectorAll(`[data-modern-idx="${mIdx}"]`);
                            elements.forEach(el => {
                                if (el !== tokenPair) {
                                    el.classList.add('scope-highlighted');
                                }
                            });
                        });
                        scopeInfo.anchors.forEach(cIdx => {
                            const elements = blockContainer.querySelectorAll(`[data-classical-idx="${cIdx}"][data-has-addition="false"]`);
                            elements.forEach(el => {
                                if (el !== tokenPair) {
                                    el.classList.add('scope-highlighted');
                                }
                            });
                        });
                    }
                });
            }
            
            if (selfId && additionTriggerMaps[blockId] && additionTriggerMaps[blockId][selfId]) {
                additionTriggerMaps[blockId][selfId].forEach(triggerId => {
                    const triggerElement = blockContainer.querySelector(`[data-self-id="${triggerId}"]`);
                    if (triggerElement) {
                        triggerElement.classList.add('trigger-highlighted');
                    }
                });
            }
            
            const classicalIdx = tokenPair.getAttribute('data-classical-idx');
            if (classicalIdx && classicalIdx !== '' && lexicalMeaningMaps[blockId] && !hasAddition) {
                const cKey = `c-${classicalIdx}`;
                const modernIndices = lexicalMeaningMaps[blockId][cKey];
                if (modernIndices && modernIndices.length > 1) {
                    const currentModernIdx = parseInt(tokenPair.getAttribute('data-modern-idx'));
                    modernIndices.forEach(mIdx => {
                        if (mIdx !== currentModernIdx) {
                            const elements = blockContainer.querySelectorAll(`[data-modern-idx="${mIdx}"]`);
                            elements.forEach(el => {
                                if (el !== tokenPair) {
                                    el.classList.add('frame-highlighted');
                                }
                            });
                        }
                    });
                }
            }
        }

        function unhighlightPair(tokenPair) {
            const blockId = tokenPair.getAttribute('data-block-id');
            const blockContainer = tokenPair.closest('.sentence-block');
            const selfId = tokenPair.getAttribute('data-self-id');
            const hasAddition = tokenPair.getAttribute('data-has-addition') === 'true';
            const hasScope = tokenPair.getAttribute('data-has-scope') === 'true';
            const scopeIdsAttr = tokenPair.getAttribute('data-scope-ids');
            const scopeIds = scopeIdsAttr ? scopeIdsAttr.split(',').map(s => parseInt(s)) : [];
            const hasParaphraseRange = tokenPair.getAttribute('data-has-paraphrase-range') === 'true';
            const paraphraseRangeId = tokenPair.getAttribute('data-paraphrase-range-id');
            
            const pairId = tokenPair.getAttribute('data-pair-id');
            if (pairId && blockContainer) {
                const pairElement = blockContainer.querySelector(`[data-self-id="${pairId}"]`);
                if (pairElement) {
                    pairElement.classList.remove('pair-highlighted');
                }
            }
            
            if (hasParaphraseRange && paraphraseRangeId && paraphraseRangeMaps[blockId]) {
                const rangeInfoList = paraphraseRangeMaps[blockId][selfId] || [];
                const rangeInfo = rangeInfoList.find(r => r.rangeId == paraphraseRangeId);
                
                if (rangeInfo) {
                    rangeInfo.allMembers.forEach(mIdx => {
                        const elements = blockContainer.querySelectorAll(`[data-modern-idx="${mIdx}"]`);
                        elements.forEach(el => {
                            el.classList.remove('paraphrase-range-highlighted');
                        });
                    });
                }
            }
            
            if (hasAddition && hasScope && scopeIds.length > 0 && scopeMaps[blockId]) {
                scopeIds.forEach(scopeId => {
                    const scopeInfoList = scopeMaps[blockId][selfId] || [];
                    const scopeInfo = scopeInfoList.find(s => s.scopeId == scopeId);
                    
                    if (scopeInfo) {
                        scopeInfo.allMembers.forEach(mIdx => {
                            const elements = blockContainer.querySelectorAll(`[data-modern-idx="${mIdx}"]`);
                            elements.forEach(el => {
                                el.classList.remove('scope-highlighted');
                            });
                        });
                        scopeInfo.anchors.forEach(cIdx => {
                            const elements = blockContainer.querySelectorAll(`[data-classical-idx="${cIdx}"]`);
                            elements.forEach(el => {
                                el.classList.remove('scope-highlighted');
                            });
                        });
                    }
                });
            }
            
            if (selfId && additionTriggerMaps[blockId] && additionTriggerMaps[blockId][selfId]) {
                additionTriggerMaps[blockId][selfId].forEach(triggerId => {
                    const triggerElement = blockContainer.querySelector(`[data-self-id="${triggerId}"]`);
                    if (triggerElement) {
                        triggerElement.classList.remove('trigger-highlighted');
                    }
                });
            }
            
            const classicalIdx = tokenPair.getAttribute('data-classical-idx');
            if (classicalIdx && classicalIdx !== '' && lexicalMeaningMaps[blockId] && !hasAddition) {
                const cKey = `c-${classicalIdx}`;
                const modernIndices = lexicalMeaningMaps[blockId][cKey];
                if (modernIndices) {
                    modernIndices.forEach(mIdx => {
                        const elements = blockContainer.querySelectorAll(`[data-modern-idx="${mIdx}"]`);
                        elements.forEach(el => {
                            el.classList.remove('frame-highlighted');
                        });
                    });
                }
            }
        }

        function renderAlignments(data, containerId, blockId) {
            const container = document.getElementById(containerId);
            container.className = 'alignment-container';
            
            const result = computeSlotPositions(data, blockId);
            const groups = groupSlotsForDisplay(result.slots, blockId);
            
            let html = '';
            let slotIndex = 0;
            
            groups.forEach(group => {
                if (group.type === 'scope-group') {
                    const enhancedClass = enhanceAddition ? 'enhanced' : '';
                    const labelVisibleClass = enhanceAddition ? 'visible' : '';
                    const scopeLabel = group.scopeIds.length > 1 ? `增譯組 ${group.scopeIds.join(',')}` : `增譯組 ${group.scopeIds[0]}`;
                    
                    html += `<div class="scope-group-wrapper ${enhancedClass}">`;
                    html += `<span class="group-label scope-label ${labelVisibleClass}">${scopeLabel}</span>`;
                    
                    group.slots.forEach(slot => {
                        html += renderTokenPair(slot, slotIndex, data, blockId);
                        slotIndex++;
                    });
                    
                    html += `</div>`;
                } else if (group.type === 'paraphrase-group') {
                    const enhancedClass = enhanceParaphrase ? 'enhanced' : '';
                    const labelVisibleClass = enhanceParaphrase ? 'visible' : '';
                    
                    html += `<div class="paraphrase-group-wrapper ${enhancedClass}">`;
                    html += `<span class="group-label paraphrase-label ${labelVisibleClass}">文意組 ${group.rangeId}</span>`;
                    
                    group.slots.forEach(slot => {
                        html += renderTokenPair(slot, slotIndex, data, blockId);
                        slotIndex++;
                    });
                    
                    html += `</div>`;
                } else if (group.type === 'addition-group') {
                    const enhancedClass = enhanceAddition ? 'enhanced' : '';
                    const labelVisibleClass = enhanceAddition ? 'visible' : '';
                    
                    html += `<div class="addition-group-wrapper ${enhancedClass}">`;
                    html += `<span class="group-label ${labelVisibleClass}">增譯: ${group.anchorRef.display}</span>`;
                    
                    group.slots.forEach(slot => {
                        html += renderTokenPair(slot, slotIndex, data, blockId);
                        slotIndex++;
                    });
                    
                    html += `</div>`;
                } else if (group.type === 'reorder-group') {
                    const groupClass = group.group === 'B' ? 'group-B' : '';
                    const enhancedClass = enhanceReorder ? 'enhanced' : '';
                    const labelVisibleClass = enhanceReorder ? 'visible' : '';
                    
                    html += `<div class="reorder-group-wrapper ${groupClass} ${enhancedClass}">`;
                    html += `<span class="group-label reorder-label ${groupClass} ${labelVisibleClass}">倒置組 ${group.group}</span>`;
                    
                    group.slots.forEach(slot => {
                        html += renderTokenPair(slot, slotIndex, data, blockId);
                        slotIndex++;
                    });
                    
                    html += `</div>`;
                } else {
                    html += renderTokenPair(group.slot, slotIndex, data, blockId);
                    slotIndex++;
                }
            });

            container.innerHTML = html;

            container.querySelectorAll('.token-pair').forEach(pair => {
                pair.addEventListener('mouseenter', function() {
                    highlightPair(this);
                });
                
                pair.addEventListener('mouseleave', function() {
                    if (!this.classList.contains('highlighted')) {
                        unhighlightPair(this);
                    }
                });
                
                pair.addEventListener('click', function() {
                    if (this.classList.contains('highlighted')) {
                        this.classList.remove('highlighted');
                        unhighlightPair(this);
                    } else {
                        if (!multiHighlightMode) {
                            document.querySelectorAll('.token-pair').forEach(p => {
                                p.classList.remove('highlighted');
                                p.classList.remove('pair-highlighted');
                                p.classList.remove('trigger-highlighted');
                                p.classList.remove('frame-highlighted');
                                p.classList.remove('scope-highlighted');
                                p.classList.remove('paraphrase-range-highlighted');
                            });
                        }
                        this.classList.add('highlighted');
                        highlightPair(this);
                    }
                });
            });
        }
        
        function applyEnhancements() {
            document.querySelectorAll('.token-pair').forEach(pair => {
                const hasEllipsis = pair.getAttribute('data-has-ellipsis') === 'true';
                const slotType = pair.getAttribute('data-slot-type');
                
                if (enhanceEllipsis && hasEllipsis && slotType !== 'reorder-classical') {
                    pair.classList.add('enhanced-ellipsis-only');
                } else {
                    pair.classList.remove('enhanced-ellipsis-only');
                }
            });
            
            document.querySelectorAll('.token-pair[data-has-reorder="true"]').forEach(pair => {
                if (enhanceReorder) {
                    pair.classList.add('enhanced-reorder-only');
                } else {
                    pair.classList.remove('enhanced-reorder-only');
                }
            });
            
            document.querySelectorAll('.token-pair').forEach(pair => {
                const hasReconstruction = pair.getAttribute('data-has-reconstruction') === 'true';
                const inFrame = pair.getAttribute('data-in-frame') === 'true';
                if (enhanceReconstruction && (hasReconstruction || inFrame)) {
                    pair.classList.add('enhanced-reconstruction');
                } else {
                    pair.classList.remove('enhanced-reconstruction');
                }
            });
            
            document.querySelectorAll('.token-pair.type-paraphrase').forEach(pair => {
                pair.classList.toggle('enhanced-paraphrase', enhanceParaphrase);
            });
            
            document.querySelectorAll('.token-pair.type-loan').forEach(pair => {
                pair.classList.toggle('enhanced-loan', enhanceLoan);
            });
            
            document.querySelectorAll('.token-pair.type-archaic').forEach(pair => {
                pair.classList.toggle('enhanced-archaic', enhanceArchaic);
            });
            
            document.querySelectorAll('.paraphrase-group-wrapper').forEach(group => {
                group.classList.toggle('enhanced', enhanceParaphrase);
            });
            document.querySelectorAll('.group-label.paraphrase-label').forEach(label => {
                label.classList.toggle('visible', enhanceParaphrase);
            });
        }

        function applyTokenVisibility() {
            document.querySelectorAll('.token-classical:not(.empty):not(.reorder-empty)').forEach(token => {
                token.classList.toggle('hidden-token', !showClassicalTokens);
            });
            document.querySelectorAll('.token-modern:not(.reorder-empty)').forEach(token => {
                token.classList.toggle('hidden-token', !showModernTokens);
            });
            document.querySelectorAll('.token-paraphrase').forEach(token => {
                token.classList.toggle('hidden-token', !showModernTokens);
            });
            
            applyRawTextVisibility();
        }

        function applyRawTextVisibility() {
            document.querySelectorAll('.raw-text-row-classical').forEach(row => {
                row.classList.toggle('hidden-row', !showClassicalTokens);
            });
            
            document.querySelectorAll('.raw-text-row-modern').forEach(row => {
                row.classList.toggle('hidden-row', !showModernTokens);
            });
            
            document.querySelectorAll('.raw-text-row-paraphrase').forEach(row => {
                const hasContent = row.getAttribute('data-has-content') === 'true';
                row.classList.toggle('hidden-row', !showModernTokens || !hasContent);
            });
        }

        function renderRawText(data, classicalId, modernId, paraphraseRowId, paraphraseId) {
            const classicalRaw = deriveRawFromTokens(data.classical);
            const modernRaw = deriveModernRawWithLabels(data);
            
            document.getElementById(classicalId).textContent = classicalRaw;
            document.getElementById(modernId).innerHTML = modernRaw;
            
            const paraphraseRow = document.getElementById(paraphraseRowId);
            const paraphraseContent = document.getElementById(paraphraseId);
            
            const paraphraseRaw = deriveParaphraseRawText(data);
            
            if (paraphraseRaw) {
                paraphraseContent.innerHTML = paraphraseRaw;
                paraphraseRow.setAttribute('data-has-content', 'true');
            } else {
                paraphraseContent.innerHTML = '';
                paraphraseRow.setAttribute('data-has-content', 'false');
            }
            
            const hasContent = paraphraseRaw !== null;
            paraphraseRow.classList.toggle('hidden-row', !showModernTokens || !hasContent);
        }

        function updateSourceInfo(block) {
            const chapter = getChapterById(block.chapterId);
            const sentences = getSentencesByChapterId(block.chapterId);
            const currentSentence = sentences[block.sentenceIndex];
            
            const commentContainer = document.getElementById(`commentTag-${block.id}`);
            if (commentContainer) {
                if (currentSentence && currentSentence.comment) {
                    commentContainer.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        ${currentSentence.comment}
                    `;
                    commentContainer.style.display = 'inline-flex';
                } else {
                    commentContainer.innerHTML = '';
                    commentContainer.style.display = 'none';
                }
            }
            
            const hintContainer = document.getElementById(`hintTag-${block.id}`);
            if (hintContainer) {
                const typeHints = currentSentence ? getSentenceTypeHints(currentSentence) : [];
                const hintText = typeHints.join(' | ');
                
                if (hintText) {
                    hintContainer.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        ${hintText}
                    `;
                    hintContainer.classList.toggle('hidden', !showHint);
                } else {
                    hintContainer.innerHTML = '';
                    hintContainer.classList.add('hidden');
                }
            }
        }

        function toggleIndexVisibility(visible) {
            showIndex = visible;
            document.querySelectorAll('.token-index').forEach(index => index.classList.toggle('visible', visible));
            document.querySelectorAll('.token-classical.empty').forEach(token => token.classList.toggle('visible', visible));
            document.querySelectorAll('.token-classical.reorder-empty').forEach(token => token.classList.toggle('visible', visible));
            document.querySelectorAll('.token-modern.reorder-empty').forEach(token => token.classList.toggle('visible', visible));
            document.querySelectorAll('.token-pair.type-addition .token-connector').forEach(connector => connector.classList.toggle('visible', visible));
            document.querySelectorAll('.token-pair.reorder-slot .token-connector').forEach(connector => connector.classList.toggle('visible', visible));
            document.querySelectorAll('.token-pair.reconstruction-duplicate .token-connector').forEach(connector => connector.classList.toggle('visible', visible));
            document.querySelectorAll('.anchor-ref').forEach(ref => ref.classList.toggle('visible', visible && enhanceAddition));
            document.getElementById('indexLegend').classList.toggle('visible', visible);
        }

        function toggleAdditionEnhancement(enhanced) {
            enhanceAddition = enhanced;
            document.querySelectorAll('.addition-group-wrapper').forEach(group => group.classList.toggle('enhanced', enhanced));
            document.querySelectorAll('.scope-group-wrapper').forEach(group => group.classList.toggle('enhanced', enhanced));
            document.querySelectorAll('.anchor-ref').forEach(ref => ref.classList.toggle('visible', enhanced && showIndex));
            document.querySelectorAll('.group-label:not(.reorder-label):not(.reconstruction-label):not(.paraphrase-label)').forEach(label => label.classList.toggle('visible', enhanced));
            
            const hasAdditions = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => hasType(a[2], '+'));
            });
            document.getElementById('additionSubtypes').classList.toggle('visible', enhanced && hasAdditions);
        }

        function toggleEllipsisEnhancement(enhanced) {
            enhanceEllipsis = enhanced;
            applyEnhancements();
            
            const hasEllipsis = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => hasType(a[2], '-'));
            });
            document.getElementById('ellipsisExplanation').classList.toggle('visible', enhanced && hasEllipsis);
        }

        function toggleParaphraseEnhancement(enhanced) {
            enhanceParaphrase = enhanced;
            applyEnhancements();
            
            const hasParaphrase = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => hasType(a[2], '#'));
            });
            document.getElementById('paraphraseExplanation').classList.toggle('visible', enhanced && hasParaphrase);
        }

        function toggleReorderEnhancement(enhanced) {
            enhanceReorder = enhanced;
            applyEnhancements();
            document.querySelectorAll('.reorder-group-wrapper').forEach(group => group.classList.toggle('enhanced', enhanced));
            document.querySelectorAll('.group-label.reorder-label').forEach(label => label.classList.toggle('visible', enhanced));
            
            const hasReorder = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => hasType(a[2], '^'));
            });
            document.getElementById('reorderExplanation').classList.toggle('visible', enhanced && hasReorder);
        }

        function toggleReconstructionEnhancement(enhanced) {
            enhanceReconstruction = enhanced;
            applyEnhancements();
            document.querySelectorAll('.reconstruction-frame-wrapper').forEach(group => group.classList.toggle('enhanced', enhanced));
            document.querySelectorAll('.group-label.reconstruction-label').forEach(label => label.classList.toggle('visible', enhanced));
            
            const hasReconstruction = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => a[3]?.frame);
            });
            document.getElementById('reconstructionExplanation').classList.toggle('visible', enhanced && hasReconstruction);
        }

        function toggleLoanEnhancement(enhanced) {
            enhanceLoan = enhanced;
            applyEnhancements();
            
            const hasLoan = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => hasType(a[2], '~'));
            });
            document.getElementById('loanExplanation').classList.toggle('visible', enhanced && hasLoan);
        }

        function toggleArchaicEnhancement(enhanced) {
            enhanceArchaic = enhanced;
            applyEnhancements();
            
            const hasArchaic = sentenceBlocks.some(block => {
                const sentences = getSentencesByChapterId(block.chapterId);
                const data = sentences[block.sentenceIndex];
                return data && data.alignments.some(a => hasType(a[2], '*'));
            });
            document.getElementById('archaicExplanation').classList.toggle('visible', enhanced && hasArchaic);
        }

        function toggleHintVisibility(visible) {
            showHint = visible;
            document.querySelectorAll('.hint-tag').forEach(tag => {
                if (!visible) {
                    tag.classList.add('hidden');
                } else {
                    if (tag.innerHTML.trim() !== '') {
                        tag.classList.remove('hidden');
                    }
                }
            });
        }

        function addSentenceBlock() {
            const newBlock = { id: nextBlockId, chapterId: "quanxue", sentenceIndex: 0, filterText: "", typeFilter: "" };
            sentenceBlocks.push(newBlock);
            nextBlockId++;
            renderAllBlocks();
        }

        function removeSentenceBlock(blockId) {
            if (sentenceBlocks.length <= 1) return;
            sentenceBlocks = sentenceBlocks.filter(block => block.id !== blockId);
            delete alignmentPairMaps[blockId];
            delete additionTriggerMaps[blockId];
            delete frameMaps[blockId];
            delete lexicalMeaningMaps[blockId];
            delete scopeMaps[blockId];
            delete additionScopeMaps[blockId];
            delete tokenScopeMaps[blockId];
            delete paraphraseRangeMaps[blockId];
            renderAllBlocks();
        }

        function updateBlockChapter(blockId, chapterId) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (block) {
                block.chapterId = chapterId;
                block.sentenceIndex = 0;
                block.filterText = "";
                block.typeFilter = "";
                renderAllBlocks();
            }
        }

        function updateBlockSentence(blockId, sentenceIndex) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (block) {
                block.sentenceIndex = sentenceIndex;
                renderBlock(block);
                updateSourceInfo(block);
                applyAllEnhancements();
            }
        }

        function navigateSentence(blockId, direction) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            const sentences = getSentencesByChapterId(block.chapterId);
            const filteredIndices = getFilteredSentenceIndices(sentences, block.filterText, block.typeFilter);
            
            if (filteredIndices.length === 0) return;
            
            const currentPosInFiltered = filteredIndices.indexOf(block.sentenceIndex);
            let newPos;
            
            if (currentPosInFiltered === -1) {
                newPos = direction > 0 ? 0 : filteredIndices.length - 1;
            } else {
                newPos = currentPosInFiltered + direction;
                if (newPos < 0) newPos = 0;
                if (newPos >= filteredIndices.length) newPos = filteredIndices.length - 1;
            }
            
            updateBlockSentence(blockId, filteredIndices[newPos]);
        }

        function jumpToSentence(blockId, targetNum) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            const sentences = getSentencesByChapterId(block.chapterId);
            const targetIndex = parseInt(targetNum) - 1;
            
            if (targetIndex >= 0 && targetIndex < sentences.length) {
                updateBlockSentence(blockId, targetIndex);
            }
        }

        function updateSentenceFilter(blockId, filterText) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            block.filterText = filterText;
            
            const sentences = getSentencesByChapterId(block.chapterId);
            const filteredIndices = getFilteredSentenceIndices(sentences, filterText, block.typeFilter);
            
            rebuildSentenceDropdown(blockId, sentences, filteredIndices, block.sentenceIndex);
            
            if (filteredIndices.length > 0 && !filteredIndices.includes(block.sentenceIndex)) {
                block.sentenceIndex = filteredIndices[0];
                renderBlock(block);
                updateSourceInfo(block);
                applyEnhancements();
            }
            
            updateProgressDisplay(blockId);
        }

        function updateTypeFilter(blockId, typeFilter) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            block.typeFilter = typeFilter;
            
            const sentences = getSentencesByChapterId(block.chapterId);
            const filteredIndices = getFilteredSentenceIndices(sentences, block.filterText, typeFilter);
            
            rebuildSentenceDropdown(blockId, sentences, filteredIndices, block.sentenceIndex);
            
            if (filteredIndices.length > 0 && !filteredIndices.includes(block.sentenceIndex)) {
                block.sentenceIndex = filteredIndices[0];
                renderBlock(block);
                updateSourceInfo(block);
                applyEnhancements();
            }
            
            updateProgressDisplay(blockId);
        }

        function rebuildSentenceDropdown(blockId, sentences, filteredIndices, currentSentenceIndex) {
            const selectElement = document.getElementById(`sentenceSelect-${blockId}`);
            if (!selectElement) return;
            
            if (filteredIndices.length === 0) {
                selectElement.innerHTML = '<option value="-1" disabled selected>（無符合結果）</option>';
                return;
            }
            
            let optionsHtml = '';
            filteredIndices.forEach(idx => {
                const sentence = sentences[idx];
                const selected = idx === currentSentenceIndex ? 'selected' : '';
                const classicalRaw = showClassicalTokens ? deriveRawFromTokens(sentence.classical) : '••••••';
                optionsHtml += `<option value="${idx}" ${selected}>句子${idx + 1}　${classicalRaw}</option>`;
            });
            
            selectElement.innerHTML = optionsHtml;
        }

        function getFilteredSentenceIndices(sentences, filterText, typeFilter) {
            let indices = sentences.map((_, idx) => idx);
            
            if (filterText && filterText.trim() !== '') {
                const searchTerm = filterText.trim().toLowerCase();
                indices = indices.filter(idx => {
                    const sentence = sentences[idx];
                    const classicalRaw = deriveRawFromTokens(sentence.classical).toLowerCase();
                    const modernRaw = sentence.modern.join('').toLowerCase();
                    return classicalRaw.includes(searchTerm) || modernRaw.includes(searchTerm);
                });
            }
            
            if (typeFilter && typeFilter !== '') {
                indices = indices.filter(idx => {
                    const sentence = sentences[idx];
                    return sentenceHasType(sentence, typeFilter);
                });
            }
            
            return indices;
        }

        function updateProgressDisplay(blockId) {
            const block = sentenceBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            const sentences = getSentencesByChapterId(block.chapterId);
            const filteredIndices = getFilteredSentenceIndices(sentences, block.filterText, block.typeFilter);
            const currentPosInFiltered = filteredIndices.indexOf(block.sentenceIndex);
            
            const progressElement = document.getElementById(`sentenceProgress-${blockId}`);
            if (progressElement) {
                if (filteredIndices.length === 0) {
                    progressElement.textContent = `0/0 (共${sentences.length})`;
                } else if (filteredIndices.length === sentences.length) {
                    progressElement.textContent = `${block.sentenceIndex + 1}/${sentences.length}`;
                } else {
                    const displayPos = currentPosInFiltered >= 0 ? currentPosInFiltered + 1 : 0;
                    progressElement.textContent = `${displayPos}/${filteredIndices.length} (共${sentences.length})`;
                }
            }
            
            const prevBtn = document.getElementById(`prevBtn-${blockId}`);
            const nextBtn = document.getElementById(`nextBtn-${blockId}`);
            
            if (prevBtn) {
                prevBtn.disabled = filteredIndices.length === 0 || currentPosInFiltered <= 0;
            }
            if (nextBtn) {
                nextBtn.disabled = filteredIndices.length === 0 || currentPosInFiltered >= filteredIndices.length - 1;
            }
        }

        function renderBlock(block) {
            const sentences = getSentencesByChapterId(block.chapterId);
            const data = sentences[block.sentenceIndex];
            if (!data) return;

            const alignmentContainerId = `alignmentContainer-${block.id}`;
            const rawClassicalId = `rawClassical-${block.id}`;
            const rawModernId = `rawModern-${block.id}`;
            const rawParaphraseRowId = `rawParaphraseRow-${block.id}`;
            const rawParaphraseId = `rawParaphrase-${block.id}`;

            renderAlignments(data, alignmentContainerId, block.id);
            renderRawText(data, rawClassicalId, rawModernId, rawParaphraseRowId, rawParaphraseId);
            
            updateProgressDisplay(block.id);
        }

        function renderAllBlocks() {
            const container = document.getElementById('sentenceBlocksContainer');

            let html = '';
            sentenceBlocks.forEach((block, index) => {
                const chapter = getChapterById(block.chapterId);
                const sentences = getSentencesByChapterId(block.chapterId);
                const currentSentence = sentences[block.sentenceIndex];
                const showRemove = sentenceBlocks.length > 1;
                const filteredIndices = getFilteredSentenceIndices(sentences, block.filterText, block.typeFilter);
                
                const hasParaphraseContent = currentSentence && sentenceHasParaphrase(currentSentence);
                
                const typeHints = currentSentence ? getSentenceTypeHints(currentSentence) : [];
                const hintText = typeHints.join(' | ');
                
                const currentPosInFiltered = filteredIndices.indexOf(block.sentenceIndex);
                const isPrevDisabled = filteredIndices.length === 0 || currentPosInFiltered <= 0;
                const isNextDisabled = filteredIndices.length === 0 || currentPosInFiltered >= filteredIndices.length - 1;
                
                let dropdownOptions;
                if (filteredIndices.length === 0) {
                    dropdownOptions = '<option value="-1" disabled selected>（無符合結果）</option>';
                } else {
                    dropdownOptions = filteredIndices.map(idx => {
                        const sentence = sentences[idx];
                        const selected = idx === block.sentenceIndex ? 'selected' : '';
                        const classicalRaw = showClassicalTokens ? deriveRawFromTokens(sentence.classical) : '••••••';
                        return `<option value="${idx}" ${selected}>句子${idx + 1}　${classicalRaw}</option>`;
                    }).join('');
                }
                
                const typeFilterOptionsHtml = typeFilterOptions.map(opt => {
                    const selected = opt.value === (block.typeFilter || '') ? 'selected' : '';
                    return `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
                }).join('');
                
                const paraphraseRowHidden = !showModernTokens || !hasParaphraseContent;
                
                let commentHtml = '';
                if (currentSentence && currentSentence.comment) {
                    commentHtml = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        ${currentSentence.comment}
                    `;
                }
                const commentDisplay = (currentSentence && currentSentence.comment) ? 'inline-flex' : 'none';
                
                let hintHtml = '';
                if (hintText) {
                    hintHtml = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        ${hintText}
                    `;
                }
                const hintHidden = !showHint || !hintText;
                
                html += `
                    <div class="sentence-block" data-block-id="${block.id}">
                        <div class="combined-selector">
                            <div class="selector-row">
                                <div class="selector-label">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                                    </svg>
                                    篇章
                                </div>
                                <div class="selector-dropdown chapter-dropdown">
                                    <select id="chapterSelect-${block.id}" onchange="updateBlockChapter(${block.id}, this.value)">
                                        ${chapters.map(ch => {
                                            const selected = ch.id === block.chapterId ? 'selected' : '';
                                            return `<option value="${ch.id}" ${selected}>${ch.author}・${ch.name}</option>`;
                                        }).join('')}
                                    </select>
                                </div>
                                <div class="block-actions">
                                    <button class="add-sentence-btn" onclick="addSentenceBlock()" title="新增句例">+</button>
                                    ${showRemove ? `<button class="remove-sentence-btn" onclick="removeSentenceBlock(${block.id})" title="移除句例">−</button>` : ''}
                                </div>
                            </div>
                            <div class="selector-row">
                                <div class="selector-label">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="17" y1="10" x2="3" y2="10"></line>
                                        <line x1="21" y1="6" x2="3" y2="6"></line>
                                        <line x1="21" y1="14" x2="3" y2="14"></line>
                                        <line x1="17" y1="18" x2="3" y2="18"></line>
                                    </svg>
                                    句子
                                </div>
                                <div class="sentence-selector-wrapper">
                                    <div class="selector-dropdown">
                                        <select id="sentenceSelect-${block.id}" onchange="updateBlockSentence(${block.id}, parseInt(this.value))">
                                            ${dropdownOptions}
                                        </select>
                                    </div>
                                    <input type="text" 
                                           class="sentence-filter-input" 
                                           id="sentenceFilter-${block.id}" 
                                           placeholder="🔍 篩選..." 
                                           value="${block.filterText || ''}"
                                           oninput="updateSentenceFilter(${block.id}, this.value)">
                                    <div class="type-filter-dropdown">
                                        <select id="typeFilter-${block.id}" onchange="updateTypeFilter(${block.id}, this.value)">
                                            ${typeFilterOptionsHtml}
                                        </select>
                                    </div>
                                    <div class="sentence-nav-controls">
                                        <button class="sentence-nav-btn" id="prevBtn-${block.id}" onclick="navigateSentence(${block.id}, -1)" title="上一句" ${isPrevDisabled ? 'disabled' : ''}>
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <polyline points="15 18 9 12 15 6"></polyline>
                                            </svg>
                                        </button>
                                        <span class="sentence-progress" id="sentenceProgress-${block.id}">${filteredIndices.length === 0 ? '0/0' : (block.sentenceIndex + 1) + '/' + sentences.length}</span>
                                        <button class="sentence-nav-btn" id="nextBtn-${block.id}" onclick="navigateSentence(${block.id}, 1)" title="下一句" ${isNextDisabled ? 'disabled' : ''}>
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <polyline points="9 18 15 12 9 6"></polyline>
                                            </svg>
                                        </button>
                                        <input type="text" 
                                               class="sentence-jump-input" 
                                               id="sentenceJump-${block.id}" 
                                               placeholder="#" 
                                               title="輸入句子編號後按 Enter 跳轉"
                                               onkeydown="if(event.key==='Enter'){jumpToSentence(${block.id}, this.value); this.value='';}"
                                               >
                                    </div>
                                </div>
                            </div>
                            <div class="source-info-inline">
                                <div class="info-item">
                                    <span class="label">典籍</span>
                                    <span class="value">${chapter.book}</span>
                                </div>
                                <div class="info-item">
                                    <span class="label">篇章</span>
                                    <span class="value">${chapter.chapter}</span>
                                </div>
                                <div class="info-item">
                                    <span class="label">作者</span>
                                    <span class="value">${chapter.author}</span>
                                </div>
                                <div class="info-item">
                                    <span class="label">時代</span>
                                    <span class="value">${chapter.era}</span>
                                </div>
                                <span class="comment-tag" id="commentTag-${block.id}" style="display: ${commentDisplay};">${commentHtml}</span>
                                <span class="hint-tag ${hintHidden ? 'hidden' : ''}" id="hintTag-${block.id}">${hintHtml}</span>
                            </div>
                        </div>

                        <div class="render-card">
                            <div class="alignment-container" id="alignmentContainer-${block.id}">
                            </div>

                            <div class="raw-text">
                                <div class="raw-text-row raw-text-row-classical ${!showClassicalTokens ? 'hidden-row' : ''}">
                                    <span class="raw-text-label">文言</span>
                                    <span class="raw-text-content" id="rawClassical-${block.id}"></span>
                                </div>
                                <div class="raw-text-row raw-text-row-modern ${!showModernTokens ? 'hidden-row' : ''}">
                                    <span class="raw-text-label">對譯</span>
                                    <span class="raw-text-content modern" id="rawModern-${block.id}"></span>
                                </div>
                                <div class="raw-text-row raw-text-row-paraphrase ${paraphraseRowHidden ? 'hidden-row' : ''}" id="rawParaphraseRow-${block.id}" data-has-content="${hasParaphraseContent}">
                                    <span class="raw-text-label">文意</span>
                                    <span class="raw-text-content paraphrase" id="rawParaphrase-${block.id}"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;

            sentenceBlocks.forEach(block => {
                renderBlock(block);
            });

            applyAllEnhancements();
        }

        function applyAllEnhancements() {
            toggleIndexVisibility(showIndex);
            toggleAdditionEnhancement(enhanceAddition);
            toggleEllipsisEnhancement(enhanceEllipsis);
            toggleParaphraseEnhancement(enhanceParaphrase);
            toggleReorderEnhancement(enhanceReorder);
            toggleReconstructionEnhancement(enhanceReconstruction);
            toggleLoanEnhancement(enhanceLoan);
            toggleArchaicEnhancement(enhanceArchaic);
            applyTokenVisibility();
        }

        // Statistics functions
function computeStatistics() {
            const stats = {
                totalChapters: chapters.length,
                chaptersData: [],
                totalSentences: 0,
                // Sentence-based type statistics
                typeStats: {
                    natural: 0,
                    ellipsis: 0,
                    addition: 0,
                    paraphrase: 0,
                    reorder: 0,
                    reconstruction: 0,
                    loan: 0,
                    archaic: 0
                },
                // Classical token-based type statistics
                tokenTypeStats: {
                    natural: 0,
                    ellipsis: 0,
                    addition: 0,
                    paraphrase: 0,
                    reorder: 0,
                    reconstruction: 0,
                    loan: 0,
                    archaic: 0
                },
                // Modern token-based type statistics (new)
                modernTokenTypeStats: {
                    natural: 0,
                    ellipsis: 0,
                    addition: 0,
                    paraphrase: 0,
                    reorder: 0,
                    reconstruction: 0,
                    loan: 0,
                    archaic: 0
                },
                totalClassicalTokensNonPunct: 0,
                totalModernTokensNonPunct: 0,
                classicalTokenFreq: {},
                modernTokenFreq: {}
            };
            
            chapters.forEach(chapter => {
                const sentences = sentencesByChapter[chapter.id] || [];
                stats.chaptersData.push({
                    id: chapter.id,
                    name: chapter.name,
                    author: chapter.author,
                    sentenceCount: sentences.length
                });
                stats.totalSentences += sentences.length;
                
                sentences.forEach(sentence => {
                    // Count classical tokens (excluding punctuation)
                    const classicalTokensNonPunct = sentence.classical.filter(token => !isPunctuation(token));
                    stats.totalClassicalTokensNonPunct += classicalTokensNonPunct.length;
                    
                    // Count modern tokens (excluding punctuation)
                    const modernTokensNonPunct = sentence.modern.filter(token => !isPunctuation(token));
                    stats.totalModernTokensNonPunct += modernTokensNonPunct.length;
                    
                    // Count classical token frequency
                    sentence.classical.forEach(token => {
                        if (!isPunctuation(token)) {
                            stats.classicalTokenFreq[token] = (stats.classicalTokenFreq[token] || 0) + 1;
                        }
                    });
                    
                    // Count modern tokens
                    sentence.modern.forEach(token => {
                        if (!isPunctuation(token)) {
                            stats.modernTokenFreq[token] = (stats.modernTokenFreq[token] || 0) + 1;
                        }
                    });
                    
                    // Build a map from classical token index to its types
                    const classicalTokenTypes = {};
                    
                    // Initialize all classical tokens (excluding punctuation)
                    sentence.classical.forEach((token, idx) => {
                        if (!isPunctuation(token)) {
                            classicalTokenTypes[idx] = new Set();
                        }
                    });
                    
                    // Build a map from modern token index to its types
                    const modernTokenTypes = {};
                    
                    // Initialize all modern tokens (excluding punctuation)
                    sentence.modern.forEach((token, idx) => {
                        if (!isPunctuation(token)) {
                            modernTokenTypes[idx] = new Set();
                        }
                    });
                    
                    // Check sentence types (sentence-level counting) and token-level analysis
                    sentence.alignments.forEach(alignment => {
                        const [cIdx, mIdx, typeStr] = alignment;
                        if (typeStr !== '') {
                            if (typeStr.includes('-')) stats.typeStats.ellipsis++;
                            if (typeStr.includes('+')) stats.typeStats.addition++;
                            if (typeStr.includes('#')) stats.typeStats.paraphrase++;
                            if (typeStr.includes('^')) stats.typeStats.reorder++;
                            if (typeStr.includes('x')) stats.typeStats.reconstruction++;
                            if (typeStr.includes('~')) stats.typeStats.loan++;
                            if (typeStr.includes('*')) stats.typeStats.archaic++;
                        }
                        
                        // Classical token-level analysis
                        if (typeof cIdx === 'number' && classicalTokenTypes[cIdx] !== undefined) {
                            if (typeStr === '') {
                                classicalTokenTypes[cIdx].add('natural');
                            } else {
                                if (typeStr.includes('-')) classicalTokenTypes[cIdx].add('ellipsis');
                                if (typeStr.includes('+')) classicalTokenTypes[cIdx].add('addition');
                                if (typeStr.includes('#')) classicalTokenTypes[cIdx].add('paraphrase');
                                if (typeStr.includes('^')) classicalTokenTypes[cIdx].add('reorder');
                                if (typeStr.includes('x')) classicalTokenTypes[cIdx].add('reconstruction');
                                if (typeStr.includes('~')) classicalTokenTypes[cIdx].add('loan');
                                if (typeStr.includes('*')) classicalTokenTypes[cIdx].add('archaic');
                            }
                        }
                        
                        // Modern token-level analysis
                        if (typeof mIdx === 'number' && modernTokenTypes[mIdx] !== undefined) {
                            if (typeStr === '') {
                                modernTokenTypes[mIdx].add('natural');
                            } else {
                                if (typeStr.includes('-')) modernTokenTypes[mIdx].add('ellipsis');
                                if (typeStr.includes('+')) modernTokenTypes[mIdx].add('addition');
                                if (typeStr.includes('#')) modernTokenTypes[mIdx].add('paraphrase');
                                if (typeStr.includes('^')) modernTokenTypes[mIdx].add('reorder');
                                if (typeStr.includes('x')) modernTokenTypes[mIdx].add('reconstruction');
                                if (typeStr.includes('~')) modernTokenTypes[mIdx].add('loan');
                                if (typeStr.includes('*')) modernTokenTypes[mIdx].add('archaic');
                            }
                        }
                    });
                    
                    // Count natural sentences (all alignments are natural)
                    const isNaturalSentence = sentence.alignments.every(a => (a[2] || '') === '');
                    if (isNaturalSentence) {
                        stats.typeStats.natural++;
                    }
                    
                    // Classical token-level counting
                    Object.keys(classicalTokenTypes).forEach(idx => {
                        const types = classicalTokenTypes[idx];
                        const hasOnlyNatural = types.size === 0 || (types.size === 1 && types.has('natural'));
                        
                        if (hasOnlyNatural) {
                            stats.tokenTypeStats.natural++;
                        } else {
                            if (types.has('ellipsis')) stats.tokenTypeStats.ellipsis++;
                            if (types.has('addition')) stats.tokenTypeStats.addition++;
                            if (types.has('paraphrase')) stats.tokenTypeStats.paraphrase++;
                            if (types.has('reorder')) stats.tokenTypeStats.reorder++;
                            if (types.has('reconstruction')) stats.tokenTypeStats.reconstruction++;
                            if (types.has('loan')) stats.tokenTypeStats.loan++;
                            if (types.has('archaic')) stats.tokenTypeStats.archaic++;
                        }
                    });
                    
                    // Modern token-level counting
                    Object.keys(modernTokenTypes).forEach(idx => {
                        const types = modernTokenTypes[idx];
                        const hasOnlyNatural = types.size === 0 || (types.size === 1 && types.has('natural'));
                        
                        if (hasOnlyNatural) {
                            stats.modernTokenTypeStats.natural++;
                        } else {
                            if (types.has('ellipsis')) stats.modernTokenTypeStats.ellipsis++;
                            if (types.has('addition')) stats.modernTokenTypeStats.addition++;
                            if (types.has('paraphrase')) stats.modernTokenTypeStats.paraphrase++;
                            if (types.has('reorder')) stats.modernTokenTypeStats.reorder++;
                            if (types.has('reconstruction')) stats.modernTokenTypeStats.reconstruction++;
                            if (types.has('loan')) stats.modernTokenTypeStats.loan++;
                            if (types.has('archaic')) stats.modernTokenTypeStats.archaic++;
                        }
                    });
                });
            });
            
            // Sort token frequency - Top 50
            stats.topClassicalTokens = Object.entries(stats.classicalTokenFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 50);
            
            stats.topModernTokens = Object.entries(stats.modernTokenFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 50);
            
            // All tokens for download
            stats.allClassicalTokens = Object.entries(stats.classicalTokenFreq)
                .sort((a, b) => b[1] - a[1]);
            
            stats.allModernTokens = Object.entries(stats.modernTokenFreq)
                .sort((a, b) => b[1] - a[1]);
            
            return stats;
        }

        function downloadTokensCSV(type) {
            const stats = computeStatistics();
            let data, filename;
            
            if (type === 'classical') {
                data = stats.allClassicalTokens;
                filename = 'classical_tokens.csv';
            } else {
                data = stats.allModernTokens;
                filename = 'modern_tokens.csv';
            }
            
            // Create CSV content
            let csvContent = '\uFEFF'; // BOM for Excel UTF-8 compatibility
            data.forEach(([token, freq]) => {
                csvContent += `${token},${freq}\n`;
            });
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function renderStatistics() {
            const stats = computeStatistics();
            const container = document.getElementById('statsContainer');
            
            let html = `
                <div class="stats-section">
                    <h3>語料庫概覽 Corpus Overview</h3>
                    <div class="stats-grid">
                        <div class="stats-item">
                            <div class="number">${stats.totalChapters}</div>
                            <div class="label">篇章數 Chapters</div>
                        </div>
                        <div class="stats-item">
                            <div class="number">${stats.totalSentences}</div>
                            <div class="label">句子總數 Total Sentences</div>
                        </div>
                        <div class="stats-item">
                            <div class="number">${Object.keys(stats.classicalTokenFreq).length}</div>
                            <div class="label">文言詞彙數 Classical Tokens (Unique)</div>
                        </div>
                        <div class="stats-item">
                            <div class="number">${Object.values(stats.classicalTokenFreq).reduce((a, b) => a + b, 0)}</div>
                            <div class="label">文言詞彙總數 Classical Tokens (Total)</div>
                        </div>
                        <div class="stats-item">
                            <div class="number">${Object.keys(stats.modernTokenFreq).length}</div>
                            <div class="label">白話詞彙數 Modern Tokens (Unique)</div>
                        </div>
                        <div class="stats-item">
                            <div class="number">${Object.values(stats.modernTokenFreq).reduce((a, b) => a + b, 0)}</div>
                            <div class="label">白話詞彙總數 Modern Tokens (Total)</div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-section">
                    <h3>各篇章句子數 Sentences by Chapter</h3>
                    <table class="stats-table">
                        <thead>
                            <tr>
                                <th>篇章 Chapter</th>
                                <th>作者 Author</th>
                                <th>句數 Sentences</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${stats.chaptersData.map(ch => `
                                <tr>
                                    <td>${ch.name}</td>
                                    <td>${ch.author}</td>
                                    <td>${ch.sentenceCount}</td>
                                </tr>
                            `).join('')}
                            <tr style="font-weight: bold; background: #f8f9fa;">
                                <td colspan="2">總計 Total</td>
                                <td>${stats.totalSentences}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
<div class="stats-section">
                    <h3>對譯類型統計 Translation Type Statistics</h3>
                    <table class="stats-table">
                        <thead>
                            <tr>
                                <th>類型 Type</th>
                                <th>代碼 Code</th>
                                <th>句子數 Sentences</th>
                                <th>文言詞數 Classical Tokens</th>
                                <th>白話詞數 Modern Tokens</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><span class="type-badge natural">自然對應</span></td>
                                <td>Type 0</td>
                                <td>${stats.typeStats.natural} (${(stats.typeStats.natural / stats.totalSentences * 100).toFixed(1)}% 完全自然句)</td>
                                <td>${stats.tokenTypeStats.natural} (${(stats.tokenTypeStats.natural / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.natural} (${(stats.modernTokenTypeStats.natural / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge ellipsis">省譯</span></td>
                                <td>Type 1 (-)</td>
                                <td>${stats.typeStats.ellipsis} (${(stats.typeStats.ellipsis / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.ellipsis} (${(stats.tokenTypeStats.ellipsis / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.ellipsis} (${(stats.modernTokenTypeStats.ellipsis / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge addition">增譯</span></td>
                                <td>Type 2 (+)</td>
                                <td>${stats.typeStats.addition} (${(stats.typeStats.addition / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.addition} (${(stats.tokenTypeStats.addition / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.addition} (${(stats.modernTokenTypeStats.addition / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge paraphrase">文意</span></td>
                                <td>Type 3 (#)</td>
                                <td>${stats.typeStats.paraphrase} (${(stats.typeStats.paraphrase / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.paraphrase} (${(stats.tokenTypeStats.paraphrase / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.paraphrase} (${(stats.modernTokenTypeStats.paraphrase / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge reorder">語序倒置</span></td>
                                <td>Type 4 (^)</td>
                                <td>${stats.typeStats.reorder} (${(stats.typeStats.reorder / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.reorder} (${(stats.tokenTypeStats.reorder / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.reorder} (${(stats.modernTokenTypeStats.reorder / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge reconstruction">重構</span></td>
                                <td>Type 5 (x)</td>
                                <td>${stats.typeStats.reconstruction} (${(stats.typeStats.reconstruction / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.reconstruction} (${(stats.tokenTypeStats.reconstruction / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.reconstruction} (${(stats.modernTokenTypeStats.reconstruction / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge loan">通假</span></td>
                                <td>Type 6 (~)</td>
                                <td>${stats.typeStats.loan} (${(stats.typeStats.loan / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.loan} (${(stats.tokenTypeStats.loan / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.loan} (${(stats.modernTokenTypeStats.loan / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr>
                                <td><span class="type-badge archaic">古今字</span></td>
                                <td>Type 7 (*)</td>
                                <td>${stats.typeStats.archaic} (${(stats.typeStats.archaic / stats.totalSentences * 100).toFixed(1)}%)</td>
                                <td>${stats.tokenTypeStats.archaic} (${(stats.tokenTypeStats.archaic / stats.totalClassicalTokensNonPunct * 100).toFixed(1)}%)</td>
                                <td>${stats.modernTokenTypeStats.archaic} (${(stats.modernTokenTypeStats.archaic / stats.totalModernTokensNonPunct * 100).toFixed(1)}%)</td>
                            </tr>
                            <tr style="font-weight: bold; background: #f8f9fa;">
                                <td colspan="2">總計 Total</td>
                                <td>${stats.totalSentences} (100%)</td>
                                <td>${stats.totalClassicalTokensNonPunct} (100%)</td>
                                <td>${stats.totalModernTokensNonPunct} (100%)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p style="font-size: 12px; color: #7f8c8d; margin-top: 10px;">
                        * 句子數：包含該類型的句子數量（一句可包含多種類型，故百分比總和可能超過100%）<br>
                        * 文言詞數：涉及該類型的文言詞彙數量（不含標點符號；一詞可涉及多種類型，故百分比總和可能超過100%）<br>
                        * 白話詞數：涉及該類型的白話詞彙數量（不含標點符號；一詞可涉及多種類型，故百分比總和可能超過100%）<br>
                        * 自然對應（句子）：指全句皆為自然對應的句子<br>
                        * 自然對應（文言詞/白話詞）：指該詞的所有對齊皆為自然對應
                    </p>
                </div>
                
                <div class="stats-section">
                    <h3>高頻文言詞彙 Top Classical Tokens (Top 50)</h3>
                    <div class="token-freq-list">
                        ${stats.topClassicalTokens.map(([token, freq]) => `
                            <span class="token-freq-item classical-token">
                                <span class="token">${token}</span>
                                <span class="freq">×${freq}</span>
                            </span>
                        `).join('')}
                    </div>
                </div>
                
                <div class="stats-section">
                    <h3>高頻白話詞彙 Top Modern Tokens (Top 50)</h3>
                    <div class="token-freq-list">
                        ${stats.topModernTokens.map(([token, freq]) => `
                            <span class="token-freq-item modern-token">
                                <span class="token">${token}</span>
                                <span class="freq">×${freq}</span>
                            </span>
                        `).join('')}
                    </div>
                </div>
                
                <div class="stats-section">
                    <h3>下載詞彙數據 Download Token Data</h3>
                    <div class="download-buttons">
                        <button class="download-btn classical-btn" onclick="downloadTokensCSV('classical')">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            下載全部文言詞彙 (CSV)
                        </button>
                        <button class="download-btn modern-btn" onclick="downloadTokensCSV('modern')">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            下載全部白話詞彙 (CSV)
                        </button>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    this.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                    
                    // Render statistics when stats tab is activated
                    if (tabId === 'stats') {
                        renderStatistics();
                    }
                });
            });
        }

// ============================================
        // Data Tab Functions
        // ============================================
        
        // Store original data for sample loading
        const originalChapters = JSON.parse(JSON.stringify(chapters));
        const originalSentencesByChapter = JSON.parse(JSON.stringify(sentencesByChapter));
        
        // Default online data URL
        const defaultOnlineDataUrl = 'https://jwilam.github.io/paratranslation/data/pt_data_test_1.txt';
        
        function getDataMode() {
            const selectedRadio = document.querySelector('input[name="dataMode"]:checked');
            return selectedRadio ? selectedRadio.value : 'replace';
        }
        
        function getChaptersAsString() {
            return `const chapters = ${JSON.stringify(chapters, null, 4)};`;
        }
        
        function getSentencesAsString() {
            return `const sentencesByChapter = ${JSON.stringify(sentencesByChapter, null, 4)};`;
        }
        
        function loadSampleData() {
            const mode = getDataMode();
            
            if (mode === 'replace') {
                // Reset to original data
                chapters.length = 0;
                originalChapters.forEach(ch => chapters.push(ch));
                
                Object.keys(sentencesByChapter).forEach(key => delete sentencesByChapter[key]);
                Object.keys(originalSentencesByChapter).forEach(key => {
                    sentencesByChapter[key] = originalSentencesByChapter[key];
                });
                
                // Update textareas
                document.getElementById('chaptersTextarea').value = getChaptersAsString();
                document.getElementById('sentencesTextarea').value = getSentencesAsString();
            } else {
                // Append mode
                const existingChapterIds = new Set(chapters.map(ch => ch.id));
                let addedChapters = 0;
                let addedSentences = 0;
                
                originalChapters.forEach(ch => {
                    if (!existingChapterIds.has(ch.id)) {
                        chapters.push(ch);
                        addedChapters++;
                    }
                });
                
                Object.keys(originalSentencesByChapter).forEach(key => {
                    if (!sentencesByChapter[key]) {
                        sentencesByChapter[key] = originalSentencesByChapter[key];
                        addedSentences += originalSentencesByChapter[key].length;
                    } else {
                        // Append sentences to existing chapter
                        const existingSentenceIds = new Set(sentencesByChapter[key].map(s => s.id));
                        originalSentencesByChapter[key].forEach(sentence => {
                            if (!existingSentenceIds.has(sentence.id)) {
                                sentencesByChapter[key].push(sentence);
                                addedSentences++;
                            }
                        });
                    }
                });
                
                // Update textareas
                document.getElementById('chaptersTextarea').value = getChaptersAsString();
                document.getElementById('sentencesTextarea').value = getSentencesAsString();
                
                showDataStatus('success', `已追加數據 Data appended: ${addedChapters} 篇章, ${addedSentences} 句子`);
            }
            
            // Reset sentence blocks and re-render
            sentenceBlocks = [{ id: 0, chapterId: chapters[0]?.id || "quanxue", sentenceIndex: 0, filterText: "", typeFilter: "" }];
            nextBlockId = 1;
            renderAllBlocks();
            
            if (getDataMode() === 'replace') {
                showDataStatus('success', '已載入內建範例數據 Sample data loaded successfully');
            }
        }
        
        function triggerFileLoad() {
            document.getElementById('fileInput').click();
        }
        
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseAndLoadData(content);
            };
            reader.onerror = function() {
                showDataStatus('error', '檔案讀取失敗 Failed to read file');
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        function showUrlModal() {
            document.getElementById('urlModalOverlay').classList.add('active');
            document.getElementById('urlInput').focus();
        }
        
        function hideUrlModal(event) {
            if (event && event.target !== document.getElementById('urlModalOverlay')) {
                return;
            }
            document.getElementById('urlModalOverlay').classList.remove('active');
        }
        
        function loadOnlineData() {
            const url = document.getElementById('urlInput').value.trim();
            
            if (!url) {
                showDataStatus('error', '請輸入網址 Please enter a URL');
                return;
            }
            
            const confirmBtn = document.getElementById('urlConfirmBtn');
            confirmBtn.disabled = true;
            confirmBtn.textContent = '載入中...';
            
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(content => {
                    hideUrlModal();
                    parseAndLoadData(content);
                })
                .catch(error => {
                    showDataStatus('error', `載入失敗 Load failed: ${error.message}`);
                })
                .finally(() => {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = '載入 Load';
                });
        }
        
        function parseAndLoadData(content) {
            try {
                // Extract chapters array
                const chaptersMatch = content.match(/const\s+chapters\s*=\s*(\[[\s\S]*?\]);/);
                // Extract sentencesByChapter object
                const sentencesMatch = content.match(/const\s+sentencesByChapter\s*=\s*(\{[\s\S]*?\});(?:\s*$|\s*\/\/|\s*const|\s*\n\s*\n)/m);
                
                if (!chaptersMatch && !sentencesMatch) {
                    // Try a more flexible pattern for sentencesByChapter
                    const flexSentencesMatch = content.match(/const\s+sentencesByChapter\s*=\s*(\{[\s\S]*\});?\s*$/m);
                    if (!chaptersMatch && !flexSentencesMatch) {
                        showDataStatus('error', '無法解析數據格式，請確認檔案包含 chapters 和 sentencesByChapter 變數');
                        return;
                    }
                }
                
                const mode = getDataMode();
                let chaptersText = '';
                let sentencesText = '';
                
                // Parse new data
                let newChapters = [];
                let newSentences = {};
                
                if (chaptersMatch) {
                    try {
                        newChapters = eval('(' + chaptersMatch[1] + ')');
                    } catch (e) {
                        console.error('Error parsing chapters:', e);
                    }
                }
                
                if (sentencesMatch) {
                    try {
                        newSentences = eval('(' + sentencesMatch[1] + ')');
                    } catch (e) {
                        console.error('Error parsing sentences:', e);
                    }
                } else {
                    // Try flexible match
                    const flexMatch = content.match(/const\s+sentencesByChapter\s*=\s*(\{[\s\S]*\})\s*;?\s*$/m);
                    if (flexMatch) {
                        try {
                            newSentences = eval('(' + flexMatch[1] + ')');
                        } catch (e) {
                            console.error('Error parsing sentences (flex):', e);
                        }
                    }
                }
                
                if (mode === 'replace') {
                    // Replace mode - update textareas directly
                    if (chaptersMatch) {
                        chaptersText = `const chapters = ${chaptersMatch[1]};`;
                        document.getElementById('chaptersTextarea').value = chaptersText;
                    }
                    if (sentencesMatch) {
                        sentencesText = `const sentencesByChapter = ${sentencesMatch[1]};`;
                        document.getElementById('sentencesTextarea').value = sentencesText;
                    } else {
                        const flexMatch = content.match(/const\s+sentencesByChapter\s*=\s*(\{[\s\S]*\})\s*;?\s*$/m);
                        if (flexMatch) {
                            sentencesText = `const sentencesByChapter = ${flexMatch[1]};`;
                            document.getElementById('sentencesTextarea').value = sentencesText;
                        }
                    }
                } else {
                    // Append mode - merge data in textareas
                    const existingChaptersText = document.getElementById('chaptersTextarea').value.trim();
                    const existingSentencesText = document.getElementById('sentencesTextarea').value.trim();
                    
                    // Parse existing data from textareas
                    let existingChapters = [];
                    let existingSentences = {};
                    
                    if (existingChaptersText) {
                        const existingChaptersMatch = existingChaptersText.match(/const\s+chapters\s*=\s*(\[[\s\S]*?\]);?/);
                        if (existingChaptersMatch) {
                            try {
                                existingChapters = eval('(' + existingChaptersMatch[1] + ')');
                            } catch (e) {}
                        }
                    }
                    
                    if (existingSentencesText) {
                        const existingSentencesMatch = existingSentencesText.match(/const\s+sentencesByChapter\s*=\s*(\{[\s\S]*\});?/);
                        if (existingSentencesMatch) {
                            try {
                                existingSentences = eval('(' + existingSentencesMatch[1] + ')');
                            } catch (e) {}
                        }
                    }
                    
                    // Merge chapters
                    const existingChapterIds = new Set(existingChapters.map(ch => ch.id));
                    let addedChapters = 0;
                    newChapters.forEach(ch => {
                        if (!existingChapterIds.has(ch.id)) {
                            existingChapters.push(ch);
                            addedChapters++;
                        }
                    });
                    
                    // Merge sentences
                    let addedSentences = 0;
                    Object.keys(newSentences).forEach(key => {
                        if (!existingSentences[key]) {
                            existingSentences[key] = newSentences[key];
                            addedSentences += newSentences[key].length;
                        } else {
                            const existingSentenceIds = new Set(existingSentences[key].map(s => s.id));
                            newSentences[key].forEach(sentence => {
                                if (!existingSentenceIds.has(sentence.id)) {
                                    existingSentences[key].push(sentence);
                                    addedSentences++;
                                }
                            });
                        }
                    });
                    
                    // Update textareas with merged data
                    document.getElementById('chaptersTextarea').value = `const chapters = ${JSON.stringify(existingChapters, null, 4)};`;
                    document.getElementById('sentencesTextarea').value = `const sentencesByChapter = ${JSON.stringify(existingSentences, null, 4)};`;
                    
                    showDataStatus('success', `已追加數據 Data appended: ${addedChapters} 篇章, ${addedSentences} 句子`);
                }
                
                // Auto-apply
                applyTextareaData();
                
            } catch (error) {
                showDataStatus('error', `解析錯誤: ${error.message}`);
            }
        }
        
        function applyTextareaData() {
            const chaptersText = document.getElementById('chaptersTextarea').value.trim();
            const sentencesText = document.getElementById('sentencesTextarea').value.trim();
            
            if (!chaptersText && !sentencesText) {
                showDataStatus('error', '請輸入數據 Please enter data');
                return;
            }
            
            try {
                // Parse chapters
                if (chaptersText) {
                    const chaptersArrayMatch = chaptersText.match(/const\s+chapters\s*=\s*(\[[\s\S]*?\]);?/);
                    if (chaptersArrayMatch) {
                        const parsedChapters = eval('(' + chaptersArrayMatch[1] + ')');
                        if (Array.isArray(parsedChapters)) {
                            chapters.length = 0;
                            parsedChapters.forEach(ch => chapters.push(ch));
                        }
                    } else {
                        // Try direct array
                        const directArray = eval('(' + chaptersText.replace(/^const\s+chapters\s*=\s*/, '').replace(/;$/, '') + ')');
                        if (Array.isArray(directArray)) {
                            chapters.length = 0;
                            directArray.forEach(ch => chapters.push(ch));
                        }
                    }
                }
                
                // Parse sentences
                if (sentencesText) {
                    const sentencesObjMatch = sentencesText.match(/const\s+sentencesByChapter\s*=\s*(\{[\s\S]*\});?/);
                    if (sentencesObjMatch) {
                        const parsedSentences = eval('(' + sentencesObjMatch[1] + ')');
                        if (typeof parsedSentences === 'object') {
                            Object.keys(sentencesByChapter).forEach(key => delete sentencesByChapter[key]);
                            Object.keys(parsedSentences).forEach(key => {
                                sentencesByChapter[key] = parsedSentences[key];
                            });
                        }
                    } else {
                        // Try direct object
                        const directObj = eval('(' + sentencesText.replace(/^const\s+sentencesByChapter\s*=\s*/, '').replace(/;$/, '') + ')');
                        if (typeof directObj === 'object') {
                            Object.keys(sentencesByChapter).forEach(key => delete sentencesByChapter[key]);
                            Object.keys(directObj).forEach(key => {
                                sentencesByChapter[key] = directObj[key];
                            });
                        }
                    }
                }
                
                // Reset and re-render
                const firstChapterId = chapters[0]?.id || Object.keys(sentencesByChapter)[0] || '';
                sentenceBlocks = [{ id: 0, chapterId: firstChapterId, sentenceIndex: 0, filterText: "", typeFilter: "" }];
                nextBlockId = 1;
                
                // Clear maps
                alignmentPairMaps = {};
                additionTriggerMaps = {};
                frameMaps = {};
                lexicalMeaningMaps = {};
                scopeMaps = {};
                additionScopeMaps = {};
                tokenScopeMaps = {};
                paraphraseRangeMaps = {};
                
                renderAllBlocks();
                
                showDataStatus('success', `數據已套用 Data applied: ${chapters.length} 篇章, ${Object.values(sentencesByChapter).flat().length} 句子`);
                
                document.getElementById('chaptersTextarea').classList.remove('error');
                document.getElementById('sentencesTextarea').classList.remove('error');
                
            } catch (error) {
                showDataStatus('error', `套用失敗: ${error.message}`);
                document.getElementById('chaptersTextarea').classList.add('error');
                document.getElementById('sentencesTextarea').classList.add('error');
            }
        }
        
        function showDataStatus(type, message) {
            const statusEl = document.getElementById('dataStatus');
            statusEl.className = 'data-status ' + type;
            statusEl.textContent = message;
            
            // Auto-hide success message after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.className = 'data-status';
                }, 5000);
            }
        }
        
        function initDataTab() {
            // Load sample data into textareas on init
            document.getElementById('chaptersTextarea').value = getChaptersAsString();
            document.getElementById('sentencesTextarea').value = getSentencesAsString();
        }

        function init() {
            initTabs();
            renderAllBlocks();
			initDataTab(); 

            document.getElementById('toggleIndex').addEventListener('change', function() {
                toggleIndexVisibility(this.checked);
            });
            document.getElementById('toggleAddition').addEventListener('change', function() {
                toggleAdditionEnhancement(this.checked);
            });
            document.getElementById('toggleEllipsis').addEventListener('change', function() {
                toggleEllipsisEnhancement(this.checked);
            });
            document.getElementById('toggleParaphrase').addEventListener('change', function() {
                toggleParaphraseEnhancement(this.checked);
            });
            document.getElementById('toggleReorder').addEventListener('change', function() {
                toggleReorderEnhancement(this.checked);
            });
            document.getElementById('toggleReconstruction').addEventListener('change', function() {
                toggleReconstructionEnhancement(this.checked);
            });
            document.getElementById('toggleLoan').addEventListener('change', function() {
                toggleLoanEnhancement(this.checked);
            });
            document.getElementById('toggleArchaic').addEventListener('change', function() {
                toggleArchaicEnhancement(this.checked);
            });
            document.getElementById('toggleMultiHighlight').addEventListener('change', function() {
                multiHighlightMode = this.checked;
            });
            document.getElementById('toggleShowClassical').addEventListener('change', function() {
                showClassicalTokens = this.checked;
                renderAllBlocks();
            });
            document.getElementById('toggleShowModern').addEventListener('change', function() {
                showModernTokens = this.checked;
                applyTokenVisibility();
                document.querySelectorAll('.raw-text-row-paraphrase').forEach(row => {
                    const hasContent = row.getAttribute('data-has-content') === 'true';
                    row.classList.toggle('hidden-row', !showModernTokens || !hasContent);
                });
            });
            document.getElementById('toggleHint').addEventListener('change', function() {
                toggleHintVisibility(this.checked);
            });
        }

        init();
    </script>
</body>
</html>